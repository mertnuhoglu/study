---
cookbook:
  basics:
    id: basics
    assert_that: [info, basic/assert_that]
    compare: [info, basic/compare]
    console: [info, basic/console]
    control: [info, basic/control]
    convert string int numeric: [info, basic/convert string int numeric]
    operators: [info, basic/operators]
    options: [info, basic/options]
    list: [info, basic/list]
    base: [info, basic/base]
    environment variables: [info, basic/environment variables]
    vector: [info, basic/vector]
    Operator precedence: [info, basic/Operator precedence]
    Loop: [info, basic/Loop]
    set operations: [info, basic/set operations]
  df2 df:
    names colnames setNames unname: [info, df/names colnames setNames unname]
    access row col: [info, df/access row col]
    columns: [info, df/columns]
    rows: [info, df/rows]
    rownames: [info, df/rownames]
    subset/query: [info, df/subset/query]
    examples/use cases: [info, df/examples/use cases]
    growing cbind rbind: [info, df/growing cbind rbind]
    filter: [info, df/filter]
    Equivalent of SQL CASE - mutate if: [info, df/Equivalent of SQL CASE - mutate if]
    tibble2: [info, df/tibble2]
  dplyr2 dplyr:
    dplyr/vignettes and tutorials: [info, dplyr/vignettes and tutorials]
    "aliases for operators:- extract [ extract2 [[": [info, "aliases for operators:- extract [ extract2 [["]
    dplyr/examples: [info, dplyr/examples]
    dplyr/debugging dplyr: [info, dplyr/debugging dplyr]
    dplyr/verbs: [info, dplyr/verbs]
    dplyr/case_when id=g12317: [info, dplyr/case_when id=g12317]
    dplyr/sample rows: [info, dplyr/sample rows]
    dplyr/grouped operations: [info, dplyr/grouped operations]
    dplyr/window functions: [info, dplyr/window functions]
    dplyr/selecting columns: [info, dplyr/selecting columns]
    dplyr/utilities: [info, dplyr/utilities]
    dplyr/databases - sql: [info, dplyr/databases - sql]
    dplyr/tally: [info, dplyr/tally]
    dplyr/do(): [info, dplyr/do()]
    dplyr/learning sql: [info, dplyr/learning sql]
    dplyr/bind_rows: [info, dplyr/bind_rows]
    dplyr/errors: [info, dplyr/errors]
    dplyr/row_number:- add sequence of row number column: [info, dplyr/row_number:- add sequence of row number column]
  apply/ldply/foreach list generations:
    apply/cases for lapply, map: [info, apply/cases for lapply, map]
    apply/lapply over names: [info, apply/lapply over names]
    apply/lapply datatable columns: [info, apply/lapply datatable columns]
    apply/for loop functionals:- lapply/sapply/vapply/mapply: [info, apply/for loop functionals:- lapply/sapply/vapply/mapply]
    apply/lapply variants lapply2: [info, apply/lapply variants lapply2]
    apply/apply() function: [info, apply/apply() function]
  convert data:- text yaml list df vector factor flatten:
    ref: ~/projects/study/r/rfc_convert_data.md
    convert_data/text -> yaml -> list -> dataframe: [info, convert_data/text -> yaml -> list -> dataframe]
    convert_data/convert list to dataframe / tree to flat: [info, convert_data/convert list to dataframe / tree to flat]
    convert_data/convert factor columns to character: [info, convert_data/convert factor columns to character]
    convert_data/convert list of vectors to dataframe: [info, convert_data/convert list of vectors to dataframe]
    convert_data/split_by into list of df: [info, convert_data/split_by into list of df]
  Data Use Cases:
    distinct-unique values of vector: unique()
    data_uc/switch: [info, data_uc/switch]
    data_uc/duplicates: [info, data_uc/duplicates]
    which: which(logical) # 1, 3
    is.na:  is.na(d1)
    data_uc/rep: [info, data_uc/rep]
    data_uc/unlist: unlist(x) # flatten
    do.call: do.call('fun', iterable) # fun(iterable[1], iterable[2] ..)
    data_uc/Access last value: [info, data_uc/Access last value]
    is.null check: is.blank() in utils.R
    split df by filename: [info, split df by filename]
    data_uc/Queries/Subsetting: [info, data_uc/Queries/Subsetting]
    data_uc/Growing: [info, data_uc/Growing]
    data_uc/Serialization: [info, data_uc/Serialization]
    data_uc/Conversions: [info, data_uc/Conversions]
    data_uc/Generate Test Data: [info, data_uc/Generate Test Data]
    data_uc/read header of csv only: [info, data_uc/read header of csv only]
    data_uc/complete: [info, data_uc/complete]
  database:
    ref: <url:file:///~/projects/study/ds/study_db_with_r.Rmd>
    database/RSQLite: [info, database/RSQLite]
    database/RPostgreSQL: [info, database/RPostgreSQL]
    database/ROracle: [info, database/ROracle]
    database/RJdbc: [info, database/RJdbc]
    database/dbplyr: [info, database/dbplyr]
  date id=g10725:
    date/why multiple date classes: [info, date/why multiple date classes]
    date/POSIX.ct ve POSIXlt: [info, date/POSIX.ct ve POSIXlt]
    date/char to POSIX.ct: [info, date/char to POSIX.ct]
    date/as.Date: [info, date/as.Date]
    date/format: [info, date/format]
    date/?strftime: _
    date/?strptime: "[info, date/?strptime]"
    date/extract year, mon out of date: [info, date/extract year, mon out of date]
    date/convert char to date: [info, date/convert char to date]
    date/lubridate: [info, date/lubridate]
    date/current date: [info, date/current date]
    date/convert string to time: [info, date/convert string to time]
    date/sequence of dates: [info, date/sequence of dates]
    date/difference of time: [info, date/difference of time]
    date/increment date by period: [info, date/increment date by period]
    date/excel date as number to posixct date: [info, date/excel date as number to posixct date]
  debug: >
    debug(fun); setBreakpoint('script.R#5')
    debug(get_olasi_kombin);
      bu durumda bu fonksiyonun ilk satırında breakpoint konulmuş olur
    browser()
    show sizes of objects
      object.size(x)
      format(object.size(x), units = "Mb")
  file system:
    file/file name from path: [info, file/file name from path]
    file/dir.create: [info, file/dir.create]
    file/list.files: [info, file/list.files]
    file/dir: [info, file/dir]
    file/list.dirs: [info, file/list.dirs]
    file/home directory: [info, file/home directory]
    file/join-concat paths: [info, file/join-concat paths]
    file/file.copy: [info, file/file.copy]
    file/file.create: [info, file/file.create]
    file/file.exists: [info, file/file.exists]
    file/file.remove: [info, file/file.remove]
    file/file.rename: [info, file/file.rename]
    file/file.append: [info, file/file.append]
    file/file.symlink: [info, file/file.symlink]
    file/file.link: [info, file/file.link]
    file/file extension: [info, file/file extension]
  fp:- partial ... purrr:
    currying: partial
    fp/purrr: [info, fp/purrr]
    fp/generifying a function using functional programming: [info, fp/generifying a function using functional programming]
    fp/problem:- how to make a function testable: [info, fp/problem:- how to make a function testable]
    fp/three dots/ellipsis/...: [info, fp/three dots/ellipsis/...]
  GIS:
    gis/sf2 sf id=g12298: [info, gis/sf2 sf id=g12298]
    gis/leaflet2 leaflet id=g12297: [info, gis/leaflet2 leaflet id=g12297]
  IO csv fread readLines read.csv readr excel sheets rio:
    io/rio: [info, io/rio]
    io/csv: [info, io/csv]
    io/fread arguments: [info, io/fread arguments]
    io/readLines writeLines - text: [info, io/readLines writeLines - text]
    io/read.csv args: [info, io/read.csv args]
    io/readr: [info, io/readr]
    io/excel2 excel readxl: [info, io/excel2 excel readxl]
    io/write excel: [info, io/write excel]
    io/read.table: [info, io/read.table]
    io/openxlsx: [info, io/openxlsx]
    io/google spreadsheets: [info, io/google spreadsheets]
    io/convention:- export(.., na = ""): [info, io/convention:- export(.., na = "")]
  json jsonr yaml - rest id=sr_0004:
    json/jsonlite: [info, json/jsonlite]
    json/jsonlite örnek: [info, json/jsonlite örnek]
    json/rjson: [info, json/rjson]
    json/ex01: [info, json/ex01]
    json/ex02: [info, json/ex02]
    json/call rest api: [info, json/call rest api]
    json/ex03: [info, json/ex03]
    json/yaml: [info, json/yaml]
  magrittr pipe:
    magrittr/basic: [info, magrittr/basic]
    magrittr/argument placeholder: [info, magrittr/argument placeholder]
    magrittr/reusing placeholder: [info, magrittr/reusing placeholder]
    magrittr/unary function: [info, magrittr/unary function]
    magrittr/create functions (or functional sequences): [info, magrittr/create functions (or functional sequences)]
    magrittr/alias: [info, magrittr/alias]
    magrittr/map function: [info, magrittr/map function]
    magrittr/argument placeholder2: [info, magrittr/argument placeholder2]
    magrittr/stepwise string-cleaning: [info, magrittr/stepwise string-cleaning]
    magrittr/paste: [info, magrittr/paste]
    magrittr/ex01: [info, magrittr/ex01]
    magrittr/assign and str: [info, magrittr/assign and str]
    magrittr/using operations instead of aliases: [info, magrittr/using operations instead of aliases]
    magrittr/tee:- return lhs: [info, magrittr/tee:- return lhs]
    magrittr/exposition of variables: [info, magrittr/exposition of variables]
    magrittr/define function on fly: [info, magrittr/define function on fly]
    magrittr/lambdas (unary function): [info, magrittr/lambdas (unary function)]
    magrittr/examples: [info, magrittr/examples]
    magrittr/pipe examples: [info, magrittr/pipe examples]
  platform:- install update system options time profiling:
    R_platform/library install.packages update upgrade install_github: [info, R_platform/library install.packages update upgrade install_github]
    R_platform/update all packages from CRAN: [info, R_platform/update all packages from CRAN]
    R_platform/Performance: [info, R_platform/Performance]
    R_platform/System: [info, R_platform/System]
    R_platform/initial/startup/default session settings: [info, R_platform/initial/startup/default session settings]
    R_platform/options/settings: [info, R_platform/options/settings]
    R_platform/packages2:- usethis: [info, R_platform/packages2:- usethis]
  rep vs replicate:
    ref:
      sequence rep length cut seq <url:file:///~/projects/study/otl/cr.otl#r=g12316>
    rep/base: a2 = data_frame( id = 5:7 )
    rep/ex01: [info, rep/ex01]
    rep/ex02: [info, rep/ex02]
    rep/ex03: [info, rep/ex03]
    rep/ex04: [info, rep/ex04]
    rep/ex05: [info, rep/ex05]
    rep/ex06: [info, rep/ex06]
  reproducible:- reprex datapasta:
    reproducible/reprex:- reproducible example codes: [info, reproducible/reprex:- reproducible example codes]
    reproducible/datapasta: [info, reproducible/datapasta]
  rmarkdown:
    rmarkdown/install: [info, rmarkdown/install]
    rmarkdown/run: [info, rmarkdown/run]
    rmarkdown/Presenter Mode: [info, rmarkdown/Presenter Mode]
    rmarkdown/adding to slides: [info, rmarkdown/adding to slides]
  Rstudio:
    rstudio/custom shortcuts: [info, rstudio/custom shortcuts]
    rstudio/View() Rstudio: [info, rstudio/View() Rstudio]
  sequence rep length cut seq id=g12316:
    sequence/rep(x, ntimes): [info, sequence/rep(x, ntimes)]
    sequence/gl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE): [info, sequence/gl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE)]
    sequence/length(x): _
    sequence/seq(from, to, by): _
    sequence/cut(x, n): _
    sequence/sample(x, size, replace = F): _
    sequence/replicate(n, expr): [info, sequence/replicate(n, expr)]
  shiny2 shiny id=g12300:
    shiny/install: [info, shiny/install]
    shiny/ref: [info, shiny/ref]
    shiny/shiny examples: [info, shiny/shiny examples]
    shiny/örnek projelerim: [info, shiny/örnek projelerim]
    shiny/run: [info, shiny/run]
    shiny/publishing to shinyapps.io: [info, shiny/publishing to shinyapps.io]
    shiny/conf: [info, shiny/conf]
    shiny/login ekranı:- shinyauthr: [info, shiny/login ekranı:- shinyauthr]
    shiny/form fields id=g12301: [info, shiny/form fields id=g12301]
  sort:
    sort/sort-order difference: [info, sort/sort-order difference]
    sort/dataframe: [info, sort/dataframe]
    sort/data table: [info, sort/data table]
  String:
    string/stringi: [info, string/stringi]
    string/substring: [info, string/substring]
    string/string templating: [info, string/string templating]
    string/paste (concat concatenate): [info, string/paste (concat concatenate)]
    string/regex: [info, string/regex]
    string/character functions: [info, string/character functions]
    string/stringr: [info, string/stringr]
    string/unicode: [info, string/unicode]
    string/examples: [info, string/examples]
  tidyr:
    tidyr/tutorial: [info, tidyr/tutorial]
    tidyr/extract_numeric: [info, tidyr/extract_numeric]
    tidyr/spread: [info, tidyr/spread]
    tidyr/unite: [info, tidyr/unite]
    tidyr/gather: [info, tidyr/gather]
    tidyr/reshape: [info, tidyr/reshape]
    tidyr/separate: [info, tidyr/separate]
  httr REST client id=g10777:
    ref: ~/projects/study/r/study_httr.Rmd 
    httr/POST: [info, httr/POST]
    httr/Debugging http requests: [info, httr/Debugging http requests]
  plumber REST services:
    plumber/ref: [info, plumber/ref]
    plumber/run plumber: [info, plumber/run plumber]
    plumber/ex01:- basic service: [info, plumber/ex01:- basic service]
    plumber/ex02:- service with argument: [info, plumber/ex02:- service with argument]
    plumber/ex04:- file upload service: [info, plumber/ex04:- file upload service]
function documentation:
  doc/rep:
    rep vs replicate: [info, rep vs replicate]
  doc/lapply:
    apply/lapply() function: [info, apply/lapply() function]
  doc/apply:
    apply/apply() function: [info, apply/apply() function]
bookmarks:
  bookmark/tools:
    bookmark/presentation library: [info, bookmark/presentation library]
    bookmark/igraph tutorial: [info, bookmark/igraph tutorial]
    bookmark/datapasta: [info, bookmark/datapasta]
index_rmd for r  id=g10652:
  Rmd:
    - ~/projects/study/r
    - ~/projects/study/r/debug_bugs.Rmd
    - ~/projects/study/r/debug_datatable_bracket_in_own_package.Rmd
    - ~/projects/study/r/debug_r_isna_all_checks_column_inside_dplyr_mutate.Rmd
    - ~/projects/study/r/df.Rmd
    - ~/projects/study/r/ex_gather_spread_group_separate_unnest.Rmd
    - ~/projects/study/r/ex_r_rmarkdown.Rmd
    - ~/projects/study/r/ex_r_time_date.Rmd
    - ~/projects/study/r/rdb_to_data.Rmd
    - ~/projects/study/r/rdb_to_ddl.Rmd
    - ~/projects/study/r/read_json.Rmd
    - ~/projects/study/r/refcard_datapasta.Rmd
    - ~/projects/study/r/refcard_loops.Rmd
    - ~/projects/study/r/study_compare.Rmd
    - ~/projects/study/r/study_httr.Rmd 
    - ~/projects/study/r/study_plumber_restful_apis.Rmd 
    - ~/projects/study/r/study_r.Rmd
    - ~/projects/study/r/study_rpostgres.Rmd
    - ~/projects/study/r/yuml_to_rdb.Rmd
    - ~/projects/study/r/yuml_to_rdb2.Rmd
info:
  apply/cases for lapply, map:
    we need to loop over this function:
      find_correct_tag = function(fn, revenue, xdca) {..}
    opt1:- make xdca global: >
      ct = Map(find_correct_tag, vxtf$filename, vxtf$revenue) %>%
        rbindlist
    opt2:- partial find_correct_tag: >
      fun1 = partial(find_correct_tag, xdca = xdca)
      ct = Map(fun1, vxtf$filename, vxtf$revenue) %>%
        rbindlist
    opt3:- use seq_along in lapply: >
      ct = lapply(seq_along(vxtf$filename), 
        function(i, vxtf, xdca) 
          find_correct_tag(vxtf[i]$filename, vxtf[i]$revenue, xdca)
        , vxtf, xdca
      ) %>%
        rbindlist
  apply/lapply over names: >
    example_apply_with_names = function() {
      ls = list( a = 3, b = 5 )
      # opt1 
      for (n in names(ls)) {
        print(ls[[n]] + 1)
      } 
      # opt2 
      lapply( seq_along(ls), function(i, ns, ls) {
          ls[[ns[i]]] + 1
        }, names(ls), ls)
      # opt4
      mapn(ls, function(elem, name) {
           print(elem + 1)
           print(name)
        })
    }
  apply/lapply() function:
    apply.lapply/ex01: [info, apply.lapply/ex01]
  apply.lapply/ex01:
    ref: apply.lapply/ex01 <url:file:///~/projects/study/r/examples_r.Rmd#r=g12618>
    kd: >
      m01 <- list(t01, t02, t03)
      lapply(m01, "[", , 2) # 2. col of each element
      lapply(m01, "[", 1, ) # 1. row of each element
  apply/apply() function:
    nrm: apply(X, MARGIN, FUN, ...)
    ref: >
      [R tutorial on the Apply family of functions - DataCamp](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family)
    MARGIN: when MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns. MARGIN=c(1,2), it applies to both rows and columns
    ex01: >
      apply(X, 2, sum)
      apply the function ‘sum’ to the matrix X along margin 2 (by column), summing up the values of each column
    apply/ex02: [info, apply/ex02]
  apply/ex02:
    ref: apply/ex02 <url:file:///~/projects/study/r/examples_r.Rmd#r=g12615>
    kd: >
      X <- matrix(c(1,2,3,4,5,6), nrow=2, ncol=3)
      apply(X, 2, sum)
      ##> [1]  3  7 11
  apply/lapply datatable columns:
    lapply(data, function(x) sprintf(t, x))
  apply/for loop functionals:- lapply/sapply/vapply/mapply:
    lapply for lists:
      for rows of data frames:- use apply
    lapply(l, f): >
      apply f to each element of list
      return:- list as l
    aggregating l elements with f: >
      lapply(l, f) %>% unlist # ==
      sapply(l, f)
      replicate(n, expr, simplify = "array")
        wrapper for sapply
      simplify
        result simplifed to vector, matrix, array?
      simplify = F, value:- list
    Map: >
      lapply:- one argument varies
      Map:- multiple args
        Map(f, list1, list2)
      mtmeans <- lapply(mtcars, mean) 
      mtmeans[] <- Map(`/`, mtcars, mtmeans) # ==
      mtcars[] <- lapply(mtcars, function(x) x / mean(x))
    mapply:
      ftr: variant of Map
      apply/do.call vs. lapply: [info, apply/do.call vs. lapply]
  apply/lapply variants lapply2:
    lapply and bind_rows:
      dlist %>% lapply(as_data_frame) %>% bind_rows()
    apply/ldfapply:- list of dataframe: [info, ldfapply:- list of dataframe]
  apply/do.call vs. lapply:
    do.call(fun, args):
      fun(args)
    lapply(args, fun): >
      args passed to fun one by one
      fun(args[[1]])
    sprintf:
      works: >
        do.call( 'sprintf', list( fmt = t, data[,1], data[,2] ) ) # works
        arg = c( list(t), as.list(data) )
        do.call( 'sprintf', arg ) # works
      not works:
        do.call( 'sprintf', t, data )
        do.call( 'sprintf', t, list(data[,1], data[,2]) )
        sprintf( t, list(data[,1], data[,2]) )
        do.call( 'sprintf', list( fmt = t, data ) )
  apply/ldfapply:- list of dataframe:
    a01: >
      # v0:- lapply
      lapply( seq_along(ldf), function( i, ldf ) {
          sheet = names(ldf)[i]
          print(sheet)
          text = unlist( ldf[i] )
          writeLines( text, paste0( "../rdm/auto_dm_", sheet, ".md" ) )
        }, ldf
      )
    a02: >
      # v1:- ldfapply
      ldfapply( ldf, function( df, n ) {
        print(n)
        text = unlist(df)
        writeLines( text, paste0( "../rdm/auto_dm_", n, ".md" ) )
      })
  basic/assert_that:
    ref: https://github.com/hadley/assertthat
    setup: >
      install.packages('assertthat')
      library('assertthat')
    replacement for stopifnot: >
      assert_that(is.character(x))
      # Error:- x is not a character vector
    examples: >
      assert_that( all_nonna(de$data_entity_id) )
      assert_that( nrow(dd) == nrow(dd3) )
      assert_that( none(n1 & n2) )
      assert_that( (sum(n1) + sum(n2) + sum(n3)) == nrow(dd4) )
      assert_that( setequal(dd$entity_name, de$entity_name) )
      assert_that( nrow(dd2) == 0 )
      assert_that( all_unique(df$data_field_id) )
  basic/compare:
    ref: study_compare.Rmd
    base R: >
      identical
      all.equal
  basic/console:
    oneliner:
      R -e 'rmarkdown::render("data_generation.Rmd", "html_document")'
    run script: >
      R CMD BATCH file.R
        # output to standard out
      Rscript file.R
        # output in a file:- file.Rout
    shebang:
      #!/usr/bin/env Rscript
  basic/control: >
    if (cond) expr1 else expr2
    for (var in seq) expr
    while (cond) expr
    ifelse(cond, yes, no)
  basic/convert string int numeric: as.numeric("3")
  basic/operators: "[ [<- [[ $ [[<- $<-"
  basic/options: >
    > options(mert_test = "selam")
    > getOption("mert_test")
    [1] "selam"
  basic/list: >
    [    # same class + multiple returns
    [[    # any type + single element
    $    # semantics similar to [[
    ls[ [length(ls)+1] ] = elem # append item
  basic/base:
    vignette: >
      browseVignettes("dplyr")
      vignette("backend", package = "DBI")
    match.arg: >
      ‘match.arg’ matches ‘arg’ against a table of candidate values as specified by ‘choices’, where ‘NULL’ means to take the first one.
      code
        my_repos <- function(type = c("all", "owner", "public", "private", "member")) {
          type <- match.arg(type)
  basic/environment variables: >
    > Sys.getenv("PATH")
    [1] "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/Library/TeX/texbin"
    > Sys.setenv(mert_test = "selam")
    > Sys.getenv("mert_test")
    [1] "selam"
  basic/vector: >
    x=c(1,2,4,8,16 )               #create a data vector with specified elements
    y=c(1:10)                 #create a data vector with elements 1-10
    vect=c(x,y)               #combine them into one vector of length 2n
  basic/Operator precedence: >
    x = text[data_starts_at+1:length(text)]
    -->
    x = text[(data_starts_at+1):length(text)]
  basic/Loop:
    vector/list:
      for (e in mylist) {...}
    data frame/table: >
      for (i in 1:nrow(df)) {
        df[i,]
        dt[i]
      # wrong:- for (row in df)
  basic/set operations:
    - union(x, y)
    - intersect(x, y)
    - setdiff(x, y)
    - setequal(x, y)
    - is.element(el, set)
  df/names colnames setNames unname:
    ref: setNames <url:file:///~/projects/study/r/examples_r.Rmd#r=g12600>
    kd: >
      colnames(df)
      setNames( 1:3, c("foo", "bar", "baz") )
        df <- data.frame(a = 1:3, b = 11:13)
        colnames(df)
          ##> [1] "a" "b"
        df2 <- setNames(df, c("X", "Y"))
        names(df2)
          ##> [1] "X" "Y"
        colnames(df2)
          ##> [1] "X" "Y"
        df = import(path) %>%
          setNames(c("IsYeri","IE_Lot_No","Stok_Kodu","Kalite_Kodu","Siparis","Str","L_Eni","L_Boy","IE_Tarihi","Terrmin_Tarihi","Miktar","sira"))
      names(df) <- tolower(names(df)) 
      unname(obj) # remove names
  df/access row col : >
    df[i,]   # row i 
    df[,j]   # column j
    tail(df, 1)
      Last row
    m[4, 2]
    m[3, ] # row
    m[ , 2] # col
  df/columns: >
    cols = names(df) %in% c("q3", "q4")
    df = df[!cols] # remove
    df = df[c(-8, -9)] # remove
    dt[ , -6:-16 ] # by range
    df[cols] # keep
    df$cols = NULL # remove
    df[ , c(2,1,3) ] # change column order
  df/rows:
    df/remove rows: [info, df/remove rows]
    df/rownames: [info, df/rownames]
  df/remove rows:
    ref: head:- remove rows of df <url:file:///~/projects/study/r/examples_r.Rmd#r=g12530>
    a01: df[ -ids, ] # remove by index
    a02: df[ !dups, ] # remove by T/F
    rule: but if ids is integer() above methods won't work
    opt1: df %>% filter(!row_number() %in% drop)
    opt2: df[!seq_len(nrow(df)) %in% drop, ]
    opt3: df[ setdiff(1:nrow(df), drop), ]
  df/rownames: rownames(f) <- c()
  df.subset/query: df[ df$col == logical ]          
  df/find rows with all NA cells:
    ref: df/find rows with all NA cells <url:file:///~/projects/study/r/examples_r.Rmd#r=g12613>
    kd: >
      d4 = data.frame( x = c(1, NA, 3), y = c(NA, NA, 3))
      applyr = purrr::partial(apply, MARGIN = 1)
      r4 = applyr(is.na(d4), all)
      r4 == c(F,T,F)
  df/remove rows with all NA values:
    df %>%
      filter( !applyr(is.na(.), all) )
  df.examples/use cases:
    df/find rows with all NA cells: [info, df/find rows with all NA cells]
    df/remove rows with all NA values: [info, df/remove rows with all NA values]
    df/loop over all columns of some df: [info, df/loop over all columns of some df]
    df/apply for dataframe is lapply: [info, df/apply for dataframe is lapply]
    df/study_create_dataframe_with_columns_specified_in_list : [info, df/study_create_dataframe_with_columns_specified_in_list ]
    dplyr.ex/read multiple sheets and bind_rows: [info, dplyr.ex/read multiple sheets and bind_rows]
  dplyr.ex/read multiple sheets and bind_rows:
    ref: dplyr.ex/read multiple sheets and bind_rows <url:file:///~/projects/study/r/examples_r.Rmd#r=g12614>
    kd: >
      vars01 <- rio::import("data/d01.xlsx", which = 1) %>%
        select(title) %>%
        mutate(title = tolower(title))
      vars02 <- rio::import("data/d01.xlsx", which = 2) %>%
        select(title) %>%
        mutate(title = tolower(title))
      vars_df <- bind_rows(vars01, vars02)
  df/loop over all columns of some df:
    common: df3 = data.frame( operation_id = df[['operation_id']] )
    opt1: >
      for (i in seq_along(cols)) {
        df3[[cols[i]]] = df[[cols[i]]]
      }
    opt2: >
      df4 = df[cols] 
    opt3: >
      df6 = lapply(seq_along(cols), function(i) df[[cols[i]]] %>% as.numeric )
    opt4: >
      df7 = lapply(cols, function(col) df[[col]] %>% as.numeric ) %>% 
        setNames(cols) %>%
        as.data.frame
      }
  df/apply for dataframe is lapply:
    convert list of vectors to dataframe: >
      df7 = lapply(cols, function(col) df[[col]] %>% as.numeric ) %>% 
        setNames(cols) %>%
        as.data.frame
      map(df, ~ str_replace_all(.x, '\\n', '') ) %>%
        as.data.frame
  df/study_create_dataframe_with_columns_specified_in_list :
    opt1: >
      l = list( a = NA, b = NA )
      df = as_data_frame(l)
    opt2: >
      l2 = setNames( replicate(2,NA, simplify = F), c('a', 'b'))
      df = as_data_frame(l2)
  df/growing cbind rbind: >
    m = cbind(m1, m2) # column bind
    rbind(df1, df2)
  df/filter: >
    iris %>% filter( column("Sepal.Length") < 5 )
      var <- "Sepal.Length"
      iris %>% filter( column(var) < 5 )
  df/Equivalent of SQL CASE - mutate if:
    ref: https://github.com/hadley/dplyr/issues/631
    ex:- if not smoker, then comsumption of cigarettes <- 0:
      a01:- standard R way: [info, mutate/standard R way]
      a02:- filter + rbind: [info, mutate/filter + rbind]
      a03:- mutate if: [info, mutate/mutate if]
      a04:- coalesce: [info, mutate/coalesce]
      a05:- case_when: [info, mutate/case_when]
      a06:- if_else: [info, mutate/if_else]
  tibble2:
    ref: "[Simple Data Frames • tibble](https://tibble.tidyverse.org/)"
    tibble oluşturma:
      tablo gibi oluşturma:- tribble: [info, tablo gibi oluşturma:- tribble]
      df tarzı oluşturma:- tibble: [info, df tarzı oluşturma:- tibble]
      convert as_tibble: [info, convert as_tibble]
    tibble::add_row: [info, tibble::add_row]
  mutate/standard R way:
    smoke$cigarrettes[!smoke$is_smoker & is.na(smoke$cigarrettes)] <- 0
  mutate/filter + rbind: >
    #dplyr option 1:- split the data set, fix one part and combine the two
    smoker_true <- smoke %>% filter(!is_smoker, is.na(smoke$cigarettes))
    # complement
    smoker_false <- smoke %>% filter(is_smoker | !is.na(smoke$cigarettes))
    smoke2 <- rbind( smoker_true %>% mutate(cigarrettes=0)
                   , smoker_false
    )
  mutate/mutate if: >
    # dplyr option 2:- replace the whole variable and do the filtering in the assignment
    smoke2 <- smoke %>%
      mutate(cigarrettes=ifelse(!is_smoker & is.na(cigarrettes), 0, cigarrettes))
  mutate/coalesce: >
    mutate(smoke, cigarettes = if_else(is_smoker, cigarettes, 0L, 0L))
  mutate/case_when: >
    mtcars %>% tbl_df %>%  transmute(size = case_when(.$cyl > 6 ~ "big", TRUE ~ "small"))
  mutate/if_else: >
    mutate(smoke, cigarettes = if_else(is_smoker, cigarettes, 0L, 0L))
  tablo gibi oluşturma:- tribble: >
    tribble(
      ~x, ~y,  ~z,
      "a", 2,  3.6,
      "b", 1,  8.5
    )
  df tarzı oluşturma:- tibble: >
    tibble(x = 1:5, y = 1, z = x ^ 2 + y)
  convert as_tibble: >
    as_tibble(iris)
  tibble::add_row: >
    library(tibble)
    df <- data_frame(x = 1:3, y = 3:1)
    add_row(df, x = 4, y = 0)
  dplyr/vignettes and tutorials: >
    http://www.dataschool.io/dplyr-tutorial-for-faster-data-manipulation-in-r/
    https://cran.r-project.org/web/packages/dplyr/vignettes/databases.html
  "aliases for operators:- extract [ extract2 [[": >
    ex01: extract2 [[
    dsc: check magrittr alias
    ?ftr: magrittr::extract2
    tbl:
      ‘extract’                 ‘`[`’
      ‘extract2’                ‘`[[`’
      ‘inset’                   ‘`[<-`’
      ‘inset2’                  ‘`[[<-`’
      ‘use_series’              ‘`$`’
      ‘add’                     ‘`+`’
      ‘subtract’                ‘`-`’
      ‘multiply_by’             ‘`*`’
      ‘raise_to_power’          ‘`^`’
      ‘multiply_by_matrix’      ‘`%*%`’
      ‘divide_by’               ‘`/`’
      ‘divide_by_int’           ‘`%/%`’
      ‘mod’                     ‘`%%`’
      ‘is_in’                   ‘`%in%`’
      ‘and’                     ‘`&`’
      ‘or’                      ‘`|`’
      ‘equals’                  ‘`==`’
      ‘is_greater_than’         ‘`>`’
      ‘is_weakly_greater_than’  ‘`>=`’
      ‘is_less_than’            ‘`<`’
      ‘is_weakly_less_than’     ‘`<=`’
      ‘not’ (‘`n'est pas`’)     ‘`!`’
      ‘set_colnames’            ‘`colnames<-`’
      ‘set_rownames’            ‘`rownames<-`’
      ‘set_names’               ‘`names<-`’
    Examples:
      iris %>%
         extract(, 1:4) %>%
         head
  dplyr/examples:
    ref: http://stackoverflow.com/questions/31358953/in-r-subset-or-dplyrfilter-with-variable-from-vector
    dplyr/rbind:- filter mutate select left_join(original): >
      fkd = r_data_field() %>%
        select( 1:2, pk_fk ) %>%
        filter( pk_fk == "FK" ) %>%
        mutate( fk_data_entity_name = ...)
        select( data_field_id, fk_data_entity_name )
      dfl = r_data_field(with_invalid=T) %>%
        select( -fk_data_entity_name ) %>%
        left_join(fkd)
      export(dfl, "data/updates/DataField_updated.tsv")
    dplyr/incremental row id: >
      fte02 = import( "inbox/formasiya_tomi_emsallari.xlsx" ) %>%
        remove_all_na_rows %>%
        mutate( fte_id = 1:n() )
    dplyr/summarise_each( funs(last(.)) ): >
      result = by_cik %>%
        summarise_each( funs(last(.)) )
    dplyr/join by multiple columns: >
      inner_join(xcr, by = c("filename", "contextRef"))
    dplyr/join by different columns: >
      org3 = org %>%
        left_join( org2, by = c("parent_id" = "organization_id") )
  dplyr/debugging dplyr:
    ref:
      https://github.com/gaborcsardi/tamper
      devtools::install_github("gaborcsardi/tamper")
      options(error = tamper::tamper)
    ex: >
      1:10 %>%
        multiply_by(10) %>%
        add(10) %>%
        add("oh no!") %>%
        subtract(5) %>%
        divide_by(5)
  dplyr/verbs:
    dplyr/mutate mutate_if:
      dplyr.mutate_if/add new columns with mutate(): [info, dplyr.mutate_if/add new columns with mutate()]
      dplyr.mutate_if/mutate if: [info, dplyr.mutate_if/mutate if]
      dplyr.mutate_if/mutate_if:- Conditional replace in-place: [info, dplyr.mutate_if/mutate_if:- Conditional replace in-place]
    dplyr/select rename:
      a01: select(flights, year, month, day)
      a02: select(flights, year:day)
      a03: select(flights, -(year:day))
      dplyr.select/helper functions: [info, dplyr.select/helper functions]
      dplyr.select/rename variables using named arguments: [info, dplyr.select/rename variables using named arguments]
      dplyr.select/order columns: [info, dplyr.select/order columns]
      dplyr.select/Select-arrange columns with character variables: [info, dplyr.select/Select-arrange columns with character variables]
    dplyr/filter slice:
      dplyr/select by position:- slice:
        slice(flights, 1:10)
      dplyr/boolean operators explicit:
        filter(flights, month == 1 | day == 1)
      a03: filter(flights, month == 1, day == 1)
      a04: >
        babynames %>%
          filter(name %>% substr(1, 3) %>% equals("Ste")) %>%
          group_by(year, sex) %>%
          summarize(total = sum(n)) %>%
          qplot(year, total, color = sex, data = ., geom = 'line') %>%
          add(ggtitle('Names starting with Ste')) %>%
          print
      dplyr/filter vector:
        files = list.files( "data/" ) %>%
          vgrepv( "\\.tsv$" )
      dplyr/slice:
        row_number'a göre filtreleme yapar: >
          slice(mtcars, 1L)
          slice(mtcars, n())
          slice(mtcars, 5:n())
          by_cyl <- group_by(mtcars, cyl)
          slice(by_cyl, 1:2)
        a02: >
          # Equivalent code using filter that will also work with databases,
          # but won't be as fast for in-memory data. For many databases, you'll
          # need to supply an explicit variable to use to compute the row number.
          filter(mtcars, row_number() == 1L)
          filter(mtcars, row_number() == n())
          filter(mtcars, between(row_number(), 5, n()))
    dplyr/arrange:
      nrm: arrange(flights, year, month, day)
      desc: >
        descending order:- desc()  
          arrange(flights, desc(year))
      more verbose:
        flights[order(flights$year, flights$month, flights$day), ]
    dplyr/summarise summarize aggregate:
      nrm: summarise(flight, delay = mean(dep_delay, na.rm = T))
      ftr01: use summarise() with aggregate functions
        that take a vector values, return a single number
      base R: min, max, sum, mean,
      dplyr: n, n_distinct(x), first(x), last(x), nth(x,n)
      ex01: expenses %>% group_by(month=lubridate::floor_date(date, "month")) %>% summarize(amount=sum(amount))
      ex02:
        destinations = group_by(flights, dest)
        summarise(destinations, 
          planes = n_distinct(tailnum),
          flights = n()
        )
      dplyr.summarize/when grouping by multiple variables, each summary peels off one level of grouping: "[info, dplyr.summarize/when grouping by multiple variables, each summary peels off one level of grouping]"
      dplyr.summarize/how does summarise_each work?: "[info, dplyr.summarize/how does summarise_each work?]"
      ex03:
        ref: <url:dropbox_btg/TEUIS PROJECT 05-ANALYSIS/working_library/requirements_database/scripts/prepare_rdb_field_operations.R#p108_rdb_gfield_aggregate_dfield>
        kd: >
          fld2 = fld %>%
            left_join(scr, by = "screen_id") %>%
            left_join(dfl, by = "data_entity_id") 
          fld3 = fld2 %>%
            group_by(field_id) %>%
            summarize(list(data_field_name))
          { # testing
            head(fld3)[[2]]
            paste(head(fld3)[[2]], collaps=",")
            toString(unlist(fld3[1,][[2]]))
            fld3[1:3,][[2]]
          }
          dfn = lapply( fld3[1:nrow(fld3),][[2]], toString ) %>% unlist
          fld4 = data_frame(
            field_id = fld3$field_id,
            data_field_name_aggregated = dfn
          )
          fld5 = fld %>%
            left_join(fld4, by = "field_id")
    dplyr/distinct:
      ttl: unique rows
      nrm: distinct(select(flights, tailnum))
      dsc: normalde sadece seçtiğin kolonları tutar
      ftr: tüm kolonları tutması için
        .keep_all = T
    dplyr/join:
      dplyr/join key:
        ttl: group_by keys
        kd: >
          delays <- flights %>%
            group_by(dest) %>%
            summarise(arr_delay = mean(arr_delay, na.rm = TRUE), n = n()) %>%
            arrange(desc(arr_delay)) %>%
            inner_join(location)
      dplyr/multiple join keys: >
        inner_join(xcr, by = c("filename", "contextRef")) 
      dplyr/join types:
        - ttl: left_join
        - ttl: inner_join
        - ttl: anti_join
          ftr: excluded in right
        - ttl: semi_join
          ftr: intersection rows
        - ttl: right_join
          ftr: reverse of left
        - ttl: outer_join
          ftr: union
      dplyr/keys to join:
        nrm: all common columns
        ftr: join by different columns
          org3 = org %>%
            left_join( org2, by = c("parent_id" = "organization_id") )
        by:
          ttl: explicitly specify
          ex01: inner_join(xcr, by = c("filename", "contextRef")) 
          ex02: inner_join(mcf, by="filename")
          ex03: >
            documentation says but doesn't work
            by = c("a")
            by = c("a" = "b")
    dplyr/mutate + transmute: _
    dplyr/sample_n + sample_frac: _
  dplyr/case_when id=g12317:
    ref:
      mutate case_when instead of mutate_if <url:file:///~/projects/study/r/examples_r.Rmd#r=g12318>
    ex01: >
      x <- 1:50
      case_when(
        x %% 35 == 0 ~ "fizz buzz",
        x %% 5 == 0 ~ "fizz",
        x %% 7 == 0 ~ "buzz",
        TRUE ~ as.character(x)
      )
  dplyr/sample rows: >
    sample_n(flights, 10)
    sample_frac(flights, 0.01)
      replace = T
  dplyr/grouped operations:
    dplyr/group by day of date:
      ref: group by day of the date  <url:file:///~/projects/study/r/examples_r.Rmd#r=g12341>
    dplyr/arrayization:
      dsc: convert single valued cells into multiple valued cells
      kd: >
        var = r_variable() %>%
          group_by( test_id ) %>%
          summarise( variable_id_list = paste( variable_id, collapse = "," ) ) 
    dplyr/unarrayization with unnest:
      ex02:
        ref: http://bioinfoblog.it/2015/02/the-most-useful-r-command-unnest-from-tidyr/comment-page-1/
        logic:
          d1
            k v
            k1  v1,v2
          ->
          d2
            k v
            k1  v1
            k1  v2
        opt1: >
          d1 %>%
            mutate( v = str_split(v, ",") ) %>%
            unnest(v)
        opt2: >
          d1 %>%
            unnest( v = str_split(v, ",") )
      ex03: >
        denp1 = r_data_entity() %>%
          select(data_entity_id, bps_id_list)
        denp2 = r_data_entity() %>%
          mutate(bps_id=str_split(bps_id_list, ",")) %>% 
          unnest(bps_id) %>%
          select(data_entity_id, bps_id)
        #> denp1
           #data_entity_id                    bps_id_list
        #1              86 1,2,3,5,6,7,8,9,10,11,12,13,14
        #2              99                             11
        #> denp2
           #data_entity_id bps_id
        #1              86      1
        #2              86      2
        #3              86      3
    dplyr/group by then summarize by concatenating the rows in each group:
      ref:
        Group by then summarize by concatenating the rows in each group:- <url:/Users/mertnuhoglu/projects/myrepo/scrap/sandbox.Rmd#tn=Group by then summarize by concatenating the rows in each group>
      code: >
        d02 <- d01 %>%
          group_by(ttl) %>%
          mutate(ftr = paste0(ftr, collapse = ".-")) %>%
          slice(1)
    dplyr/group_by and concat strings by column: >
      rvw2 = rvw %>%
        left_join( vsc, by = "view_id" ) %>%
        left_join( scw, by = "screen_id" ) %>%
        group_by( view_id ) %>%
        distinct( window_id ) %>%
        summarise( window_id_list = paste( window_id, collapse = "," ) ) %>%
        arrange( view_id )
    dplyr/filter first row from group_by: >
      ref: http://stackoverflow.com/questions/31528981/dplyr-select-first-and-last-row-from-grouped-data
      opt1: >
        row_number() == 1
        df %>%
          group_by(id) %>%
          arrange(stopSequence) %>%
          filter(row_number()==1 | row_number()==n())
      opt2: >
        slice(1)
        df %>% arrange(stopSequence) %>% group_by(id) %>% slice(c(1,n()))
    dplyr/verbs affected by grouping as:
      select(): no change
      arrange(): orders first by grouping variables
      mutate() and filter(): most usefil with window functions (rank() or min(x) == x)
        vignette("window-function")
      sample_n(): sample rows in each group
      slice(): extract rows within each group
      summarise(): explained below
    dplyr/example: >
      planes = group_by(flights, tailnum)
      delay = summarise(planes,
        count = n(),
        dist = mean(distance, na.rm = T),
        delay = mean(arr_delay, na.rm = T))
      delay = filter(delay, count > 20, dist < 2000)
    dplyr/grouping without summarising: >
      flights %>%
        group_by(Dest) %>%
        select(Cancelled) %>%
        table() %>%
        head()
  dplyr/window functions:
    dsc: n inputs and n outputs
    ex01: >
      filter(min_rank(desc(DepDelay)) <= 2) %>%
      =
      top_n(2) %>%
      # for each month, calculate the number of flights and the change from the previous month
      flights %>%
        group_by(Month) %>%
        summarise(flight_count = n()) %>%
        mutate(change = flight_count - lag(flight_count))
      # rewrite more simply with tally
        tally() %>%
        mutate(change = n - lag(n))
      # row numbers of each element in each group
      r2 %>%
        group_by( from ) %>%
        mutate( order2 = row_number(order) )
      # from to order order2
      #    a  b     1      1
      #    a  c     1      2
      #    b  d     2      1
      r2 %>%
        group_by( from ) %>%
        mutate( order2 = row_number() )
      # from to order order2
      #    a  b     1      1
      #    a  c     1      2
      #    b  d     2      1
    dplyr/ranking:
      dplyr.ranking/functions: [info, dplyr.ranking/functions]
      dplyr.ranking/example: [info, dplyr.ranking/example]
      dplyr.ranking/how to handle ties: [info, dplyr.ranking/how to handle ties]
      difference:
        how to solve ties
  dplyr/selecting columns:
    dplyr/select by suffix/prefix:
      base: cols = c("op_id", "no")
      opt1:
        cols[ends_with(cols, '_id')]
      opt2: >
        cols %>%
          extract( ends_with(., '_id') )
    opt1: >
      cols = cols[ends_with(cols, '_id')] 
      df4 = df[cols]
    opt2: >
      df5 = df %>%
        extract( cols[ends_with(cols, '_id')] )
  dplyr/utilities:
    instead of str(): glimpse(flights)
  dplyr/databases - sql:
    dplyr/connect to database:
      jdbc - most reliable: >
        username = "btg_mis"
        password = "..."
        conStr =  "jdbc:oracle:thin:@52.73.23.191:1521:btgdev"
        drv <- JDBC("oracle.jdbc.driver.OracleDriver",
          "other/ojdbc6.jar",
          identifier.quote="`")
        conn = dbConnect(drv, conStr, username, password)
      a02: my_db = src_sqlite("my_db.sqlite3")
    dplyr/create new database:
      my_db <- src_sqlite("my_db.sqlite3", create = T)
    dplyr/read table: >
      dbReadTibble = function(db, table_name) {
        dbReadTable(db, table_name) %>%
          as_tibble
      }
      act_evt_log = function(db) dbReadTibble(db, "ACT_EVT_LOG")
    dplyr/select query:- dbGetQuery() or tbl():
      dsc: load/read data:- database to df
      base: conn = get_db_aws()
      nrm: df = dbGetQuery(conn, "SELECT * FROM T_TEST")
      a01: weather_db <- hflights_db %>% tbl("weather")
    dplyr/dplyr/connect to: _
    dplyr/select queries with tbl(): >
      tbl(my_db, "hflights")
      tbl(my_db, sql("SELECT * FROM hflights LIMIT 100"))
    dplyr/convert dplyr to sql:- explain(): >
      show sql and show plan
      flights_db %>% filter(n > 10) %>% explain()
    dplyr/insert/copy df to database:- copy_to():
      copy_to(hflights_db, as.data.frame(flights), name = "flights", 
        indexes = list(c("date", "hour"), "plane", "dest", "arr"), temporary = FALSE)
    dplyr/work with data as if they are local data frames: >
      flights_db %>% left_join(planes_db)
      operations are lazy, until you see the data
    dplyr/get all data locally:
      hourly_local <- collect(hourly)
  dplyr/tally: >
    planes %>% group_by(type) %>% tally()
    simple count() by group
  dplyr/do():
    ttl: if existing verbs don't work, use do()
    ftr: >
      similar to dlply()
      slower
      uses pronoun:- . to refer to current group
    ex: >
      df:- houseID, year, price
      by_house = df %>% 
        group_by(houseID) 
      by_house %>% do(na.locf(.))
        na.locf:- last observation carried forward. replace na with last non-na value
      by_house %>% do(head(., 2))
      by_house %>% do(data.frame(year = .$year[1]))
  dplyr/learning sql:
    dplyr/how indices work:
      sqlite.org/queryplanner.html
    dplyr/how select works:
      10 easy steps to a complete understanding of sql
  dplyr/bind_rows: >
    do.call(rbind, x) # ==
    bind_rows(x)
  dplyr/errors:
    a01: >
      # Error:- `false` has type 'integer' not 'double'
      sip3 %>%
        mutate( bicak_sayisi = if_else( T, 1, as.integer(1) ))
      if_else'in tüm çıktıları aynı type'ta olmalı. fakat integer ve numeric farklı tipler.
      ex2
        if_else:- Error:- `false` has type 'logical' not 'double'
          if_else(TRUE, 1, NA)
          #> Error:- `false` has type 'logical' not 'double'
          if_else(TRUE, 1, NA_real_)
          #> [1] 1
    a02: >
      error:- index out of bounds
      join key mevcut değil
    a03: >
      Error:- argument "x" is missing, with no default
      4:- lapply(result, . %>% "kombin"[[]]) %>% bind_rows() %>% mutate(kombin_id = row_number()) at optimize_trim_in_one_step.R#70
      sebep:- 
        result = list()
  dplyr/row_number:- add sequence of row number column: >
    [r - Add an index (numeric ID) column to large data frame - Stack Overflow](https://stackoverflow.com/questions/23518605/add-an-index-numeric-id-column-to-large-data-frame/23518737)
      df <- df %>% mutate(id = row_number())
  dplyr.mutate_if/add new columns with mutate():
    mutate(flights, gain = arr_delay - dep_delay)
  dplyr.mutate_if/mutate if:
    basic: mutate( type = ifelse(  f$type == f$field, NA, f$type ) )
    opts:
      data.table: >
        id = "field_id" 
        flden = import("data/translation/field_en.xlsx") %>%
          select( one_of("field_id"), ends_with("_en") ) %>%
          as.data.table
        setkey(flden, field_id)
        flden2 = flden[!is.na(field_name_en)]
        fld = read_rdb_field() %>%
          as.data.table
        setkey(fld, field_id)
        assert_that(all( flden2$field_id %in% fld$field_id ) )
        fld2 = fld
        fld2[field_id %in% flden2$field_id]$field_name_en = flden2$field_name_en
        assert_that( setequal( fld[[id]], fld2[[id]] ) )
        export(fld2, "data/translation/field2.tsv")
      dplyr: >
        id = "field_id" 
        flden = import("data/translation/field_en.xlsx") %>%
          select( one_of("field_id"), ends_with("_en") )
        fld = read_rdb_field()
        fld2 = fld %>%
          left_join( flden, by = id) %>%
          mutate( field_name_en = ifelse( is.na(field_name_en.y), field_name_en.x, field_name_en.y )) %>%
          select( -one_of("field_name_en.y", "field_name_en.x") )
        assert_that( setequal( fld[[id]], fld2[[id]] ) )
        export(fld2, "data/translation/field2.tsv")
  dplyr.mutate_if/mutate_if:- Conditional replace in-place:
    deprecated: use case_when
    ref: case_when      <url:file:///~/projects/study/otl/cr.otl#r=g12317>
    basic: mutate_if(df,a==3,x=100)
    use:
      mutate( type = ifelse(  f$type == f$field, NA, f$type ) )
  dplyr.select/helper functions: >
    starts_with()
    ends_with
    matches()
    contains()
    ?select
  dplyr.select/rename variables using named arguments: >
    select(flights, tail_num = tailnum) # others are dropped
    rename(flights, tail_num = tailnum)
    rename using string functions
      iris %>% rename_(.dots=setNames(names(.), tolower(gsub("\\.", "_", names(.)))))
  dplyr.select/order columns:
    a01: select(field_id, data_entity_id:variable_name)
    dplyr.select/remaining columns ordering:
      ref: http://stackoverflow.com/questions/32040742/dplyrselect-including-all-other-columns-at-end-of-new-data-frame-or-beginni
      dplyr.select/all other (remaining) columns at end: >
        col <- c("carrier", "tailnum", "year", "month", "day")
        select(flights, one_of(col), everything()) 
      dplyr.select/all other at beginning:
        select(flights, -one_of(col), one_of(col))
      dplyr.select/all dataframe at end:
        bind_cols(select(flights, one_of(col)), flights)
      dplyr.select/all dataframe at beginning:
        bind_cols(flights, select(flights, one_of(col)))
  dplyr.select/Select-arrange columns with character variables:
    a01: >
      cols = c("mpg","cyl, hp:vs")
      mtcars %.%
        filter(gear == 3,cyl == 8) %.%
        s_select(cols)
    a02:
      s_arrange(mtcars, c("gear", "-mpg"))
    nrm:
      select(mpg, cyl)
  dplyr.summarize/funs(...) applied to each column separately:
    a01: >
      > by_species %>% summarise_each(funs(mean), matches("Width"))
      Source:- local data frame [3 x 3]
           Species Sepal.Width Petal.Width
      1     setosa       3.428       0.246
      2 versicolor       2.770       1.326
      3  virginica       2.974       2.026
    a02: >
      > by_species %>% summarise_each(funs(mean), Petal.Width)
      Source:- local data frame [3 x 2]
           Species Petal.Width
      1     setosa       0.246
      2 versicolor       1.326
      3  virginica       2.026
  dplyr.summarize/when grouping by multiple variables, each summary peels off one level of grouping: >
    daily = group_by(flights, year, month, day)
    per_day = summarise(daily, flights = n())
    per_month = summarise(per_day, flights = sum(flights))
  dplyr.summarize/how does summarise_each work?:
    ex: >
      > by_species <- iris %>% group_by(Species)
      > by_species %>% summarise_each(funs(length))
      Source:- local data frame [3 x 5]
           Species Sepal.Length Sepal.Width Petal.Length Petal.Width
      1     setosa           50          50           50          50
      2 versicolor           50          50           50          50
      3  virginica           50          50           50          50
    dplyr.summarize/funs(...) applied to each column separately: [info, dplyr.summarize/funs(...) applied to each column separately]
  dplyr.ranking/functions: >
    row_number
    min_rank
    dense_rank
  dplyr.ranking/example: >
    nums = c(1, 1, 2, 3)
    > min_rank(nums)
    [1] 1 1 3 4
    > dense_rank(nums)
    [1] 1 1 2 3
    > row_number(nums)
    [1] 1 2 3 4
  dplyr.ranking/how to handle ties: >
    min_rank: normal ranking
    dense_rank: doesn't skip the places
    row_number: ignores ties
  convert_data/text -> yaml -> list -> dataframe: >
    study_build_ddl_2_table = function() {
      ddl = readLines("data/delete_sql/hibernate_ddl_create_table.sql")
      out = ddl %>%
        str_replace_all("create table", "") %>%
        str_replace_all("number\\([^)]*\\)[^,]*", "") %>%
        str_replace_all("varchar2?\\([^)]*\\)", "") %>%
        str_replace_all("primary key *\\([^)]*\\)", "") %>%
        str_replace_all(", *\\)$", "") %>%
        str_replace_all(" *\\(", "\t") %>%
        str_replace_all(" *, *", "\t") %>%
        str_trim(side = "both")
      writeLines(out, "data/delete_sql/ddl_out1.txt")
      out2 = out %>%
        str_replace_all("\t(\\w+)", "\n  - \\1") %>%
        str_trim(side = "both") %>%
        str_replace_all("^(\\w+)", "\\1:") %>%
        str_trim(side = "both") 
      writeLines(out2, "data/delete_sql/ddl_out2.yaml")
      yml = yaml.load_file( "data/delete_sql/ddl_out2.yaml")
      extract_columns = function(i, yml) {
        table = yml[i] %>% names
        data_frame( 
          table_name = table,
          column_name = yml[[table]] 
        )
      }
      out3 = lapply( seq_along(yml), extract_columns, yml) %>%
        bind_rows
      writeLines(out3, "data/delete_sql/ddl_out3.tsv" )
    }
  convert_data/convert list to dataframe / tree to flat:
    convert_data/opt7:- purr map_chr: [info, convert_data/opt7:- purr map_chr]
    convert_data/opt6:- str_split unnest group_by spread: [info, convert_data/opt6:- str_split unnest group_by spread]
    convert_data/opt5:- using nest: [info, convert_data/opt5:- using nest]
    convert_data/opt1:- list to dataframe: [info, convert_data/opt1:- list to dataframe]
    convert_data/opt2:- list to dataframe: [info, convert_data/opt2:- list to dataframe]
    convert_data/opt3:- list to dataframe: [info, convert_data/opt3:- list to dataframe]
    convert_data/opt4:- manual lapply per each list: [info, convert_data/opt4:- manual lapply per each list]
  convert_data/convert factor columns to character:
    ref: http://stackoverflow.com/questions/2851015/convert-data-frame-columns-from-factors-to-characters
    opt1:- lapply df[]: >
      df[] = lapply(df, as.character)
    opt2:- purr: >
      bob %>% map_if(is.factor, as.character)
  convert_data/convert list of vectors to dataframe: >
    df7 = lapply(cols, function(col) df[[col]] %>% as.numeric ) %>% 
      setNames(cols) %>%
      as.data.frame
  convert_data/split_by into list of df: >
    lapply( ect$enum_category_id, function( ecid, evl ) {
      filter( evl, enum_category_id == ecid )
    }, evl )
  convert_data/opt7:- purr map_chr: >
    repos = my_repos("owner", limit = 100)
    toJSON(repos) %>%
      writeLines( "data/repos.json" )
    df = tibble(
      name = repos %>% map_chr("name", .null = NA_character_),
      full_name = repos %>% map_chr("full_name", .null = NA_character_)
    )
  convert_data/opt6:- str_split unnest group_by spread: >
    str_split then convert to dataframe column  <url:#r=sr_0003>
  convert_data/opt5:- using nest: >
    mygenes
      Entrez  symbols
      7841    MOGS,CDG2B,CWH41,DER7,GCS1 
    mygenes %>% 
      mutate(symbols=strsplit(as.character(symbols), ",")) %>% 
      unnest(symbols)
           Entrez symbols
        1    7841    MOGS
        2    7841   CDG2B
        3    7841   CWH41 
  convert_data/opt1:- list to dataframe: >
    https://gist.github.com/aammd/9ae2f5cce9afd799bafb
    https://github.com/krlmlr/kimisc/blob/develop/R/list_to_df.R
      unnamed.list <- replicate(10,rand_mat(),simplify = FALSE) 
      named.list <- unnamed.list %>% set_names(LETTERS[1:10])
      list_to_df <- function(listfordf){
        if(!is.list(named.list)) stop("it should be a list")
      df <- list(list.element = listfordf)
      class(df) <- c("tbl_df", "data.frame")
      attr(df, "row.names") <- .set_row_names(length(listfordf))
      if (!is.null(names(listfordf))) {
        df$name <- names(listfordf)
      }
      df
    }
    rand_mat <- function() {
      Nrow <- sample(2:15,1)
      Ncol <- sample(2:15,1)
      rpois(Nrow*Ncol,20) %>%
        matrix(nrow = Nrow,ncol = Ncol)
    }
    list_to_df(unnamed.list)
  convert_data/opt2:- list to dataframe: >
    http://stackoverflow.com/questions/29265702/r-reorganize-list-into-dataframe-using-dplyr
    l =list()
    l[[1]] = list(member1=c(a=rnorm(1)),member2=matrix(rnorm(3),nrow=3,ncol=1 2016-06-12imnames=list(c(letters[2:4]),c("sample"))))
    l[[2]] = list(member1=c(a=rnorm(1)),member2=matrix(rnorm(3),nrow=3,ncol=1 2016-06-12imnames=list(c(letters[2:4]),c("sample"))))
    l[[3]] = list(member1=c(a=rnorm(1)),member2=matrix(rnorm(3),nrow=3,ncol=1 2016-06-12imnames=list(c(letters[2:4]),c("sample"))))
    lapply(l, `[[`, 2) %>% 
      data.frame %>% 
      add_rownames("key") %>% 
      gather(x, value, -key) %>% 
      select(-x) 
  convert_data/opt3:- list to dataframe: >
    obs1 <- list(x="a", value=123)
    obs2 <- list(x="b", value=27)
    obs3 <- list(x="c", value=99)
    dlist <- list(obs1, obs2, obs3)
    dlist
    opt1:- lapply: >
      dlist %>% lapply(as_data_frame) %>% bind_rows()
      df %>% lapply(as_data_frame) %>% bind_rows()
    opt2:- do.call: >
      as.data.frame(do.call(rbind, dlist), stringsAsFactors = FALSE) 
  convert_data/opt4:- manual lapply per each list:
    ref: study_convert_list_to_dataframe = function() { <url:file:///~/dropbox_btg/TEUIS PROJECT 05-ANALYSIS/working_library/requirements_database/scripts/verify_enums.R#r=g10023>
  data_uc/switch: >
    switch(ext,
      txt=dir_filings_txt(),
      xml=dir_filings_xbrl(),
      zip=dir_filings_zip(),
      xbrl=dir_filings_xbrl())
  data_uc/duplicates:
    data_uc/duplicated rows in dplyr: [info, data_uc/duplicated rows in dplyr]
    data_uc/a01: [info, data_uc/a01]
    data_uc/get both: [info, data_uc/get both]
    data_uc/Remove duplicate rows : [info, data_uc/Remove duplicate rows ]
    data_uc/filter and select duplicate values: [info, data_uc/filter and select duplicate values]
    data_uc/a02: [info, data_uc/a02]
  data_uc/rep: 
    nrm: rep(x, times)
    ref: sequence rep length cut seq <url:file:///~/projects/study/otl/cr.otl#r=g12316>
  data_uc/unlist: unlist(x) # flatten
  data_uc/Access last value:
    vector: tail(vector, n=1)
    data frame: >
      x[length(x[,1]),]
      x[dim(x)[1],]
      x[nrow(x),]
  data_uc/Queries/Subsetting:
    Assignment if true:
      df$agecat[age > 75] <- "Elder"
    how many exists?: >
      a = length( which(x$category == 'I.setosa') )
    non na values from vector: >
      d[!is.na(d)]
    non na rows from df: >
      filter_nonna = function(df, column) {
        df[!is.na(df[[column]]), ]
      }
      filter_nonna(df, "enum_id")
  data_uc/Growing:
    build parts then join them: >
      using for loop
        rl = vector('list', n)
        for(i in 1:n) {
          rl[[i]] = data.table(..)
        }
        dt = do.call('rbind', rl)
      dt = rbindlist(rl) # better
        rbindlist bug
          when columns order is different, rbindlist will produce nonsense 
          use use.names=T
  data_uc/Serialization: >
    saveRDS(women, "women.rds")
    women2 <- readRDS("women.rds")
    dput(mean, "foo") # write in ascii
    bar <- dget("foo")
    unlink("foo") # remove
  data_uc/Conversions:
    dataframe to datatable:
      den = read_excel2(path, 'DataEntity') %>% data.table
    list to data frame/table:
      best: >
        mylist %>%
          purrr::map_df(rutils::safe_extract, c("ttl", "ftr", "opt"))
      opt1: >
        my.df <- do.call('rbind', my.list)
        rbindlist(my.list)
      opt2: >
        as.data.frame(e)
      opt3:- differing sizes: >
        test4 <- list('Row1'=letters[1:5], 'Row2'=letters[1:7], 'Row3'=letters[8:14])
        as.data.table(test4)
      ref: http://www.r-bloggers.com/converting-a-list-to-a-data-frame/
    dataframe to list conversion:
      a01:- transpose and as.list. elements are vectors: >
        dl2 = df %>%
          t %>%
          as.data.frame %>%
          as.list
      a02:- unlist. elements are vectors: >
        dl3 = df %>%
          apply(1, list) %>%
          unlist(recursive = F)
    convert vector to list:
      as.list(c(1,2,3)
    vector to list: >
      kn <- c("1", "a", "b")
      nl <- vector(mode="list", length=length(kn)-1)
      names(nl) <- kn[-1]
      ml <- lapply(nl, function(x) kn[1])
      ml
        $a
        [1] "1"
        $b
        [1] "1"
    build list from a vector and multiple valued vector:
      input: >
        > tags
        [[1]]
        [1] "Revenues"                "SalesRevenueServicesNet"
        [[2]]
        [1] "Revenues"
        > f
        [1] "1000045-0001193125-14-237425" "1000180-0001000180-15-000013"
      target: >
        ft 
        [[1]]
        $filename "100045"
        $tags list
          [[1]] "Revenues" ...
      using for loop: >
        ft = vector("list", length(f))
        for (i in seq_along(ft)) {
          ft[[i]]$filename = f[i]
          ft[[i]]$tags = tags[[i]]
        }
      using lapply: >
        ft2 = lapply(seq_along(f), 
          function(i, f, tags)
            list(
              filename = f[[i]],
              tags = tags[[i]]
            ),
          f, tags
          )
        identical(ft, ft2)
  data_uc/Generate Test Data:
    a01: >
      sample_with_replace = function(v, n = 100) sample(v, size = n, replace = T)
      auction_data = data.frame(
        Price = 1:100 %>% sample_with_replace)
    a02: >
      sample_datatable = function(dt, n = 100) dt[ sample(nrow(dt), size = n) ]
      s = auction_data %>% sample_datatable(5)
  data_uc/read header of csv only: >
    con = file("data/flights4.csv")
    open(con)
    h4 = read.table(con, skip = 0, nrow = 1, sep = ",") %>% 
      unlist %>% unname
    close(con)
  data_uc/complete: >
    It turns implicitly missing values into explicitly missing values.
    df <- data_frame(
      group = c(1:2, 1),
      item_id = c(1:2, 2),
      item_name = c("a", "b", "b"),
      value1 = 1:3,
      value2 = 4:6
    )
    df %>% complete(group, c(item_id, item_name))
      group item_id item_name value1 value2
      1       1         a      1      4
      1       2         b      3      6
      2       1         a     NA     NA
      2       2         b      2      5
    df
      Source: local data frame [3 x 5]
      group item_id item_name value1 value2
      1       1         a      1      4
      2       2         b      2      5
      1       2         b      3      6
  data_uc/duplicated rows in dplyr: >
    # opt1: duplikasyonları ve orjinal kayıtları siler
    dups8 = dd8 %>%
      group_by( entity_name, data_field_name ) %>%
      filter( n() > 1 )
    # opt2: sadece duplikasyonları siler
    dups8b = dd8 %>%
      distinct( entity_name, data_field_name, .keep_all = T ) 
    duplicated_rows = function(df, column) {
      fld %>%
        group_by_(column) %>%
        filter( n() > 1 )
    }
    duplicated_rows(fld, "field_id")
  data_uc/a01: 
    duplicated(vec) # T, F, T
  data_uc/get both: >
    duplicated and its reference
    x = c(1,3,1)
    duplicated(x) | duplicated(x, fromLast = T)
  data_uc/Remove duplicate rows : >
    dups = duplicated( dt$cik )
    dt[!dups] 
  data_uc/filter and select duplicate values: >
    v = filter_nonna(df, "enum_id")$enum_id
    v[ duplicated(v) ]
    ===
    duplicated_values = function(df, column) {
      v = filter_nonna(df, column)[[column]]
      v[ duplicated(v) ] %>% unique
    }
    duplicated_values(df, "enum_id")
  data_uc/a02: 
    all_unique = function(v) { duplicated(v) %>% sum == 0 }
  database/RSQLite: >
    install.packages("RSQLite")
    library("RSQLite")
  database/RPostgreSQL:
    install: >
      install.packages("RPostgreSQL")
      library("RPostgreSQL")
    dbDriver: _
    dbConnect: dbDisconnect
    dbApply: apply function to each row
    dbCallProc: call stored procedure
    dbCommit: dbRollback
    dbGetInfo: >
      dbGetInfo(rs, what = "rowsAffected")
      names(dbGetInfo)
    ex: >
      dbDriver
      con = dbConnect(..)
      df = dbGetQuery(con, ..)
      rs = dbSendQuery(..)
      df = fetch(rs, n = -1)
    dbDataType: _
    dbListTables: _
    dbReadTable:
      dbRemoveTable: _
      dbWriteTable: >
        append
          If the ‘append’ argument is ‘TRUE’, the rows in an existing table
          are preserved, and the new data are appended. If the table doesn't
          exist yet, it is created.
          Note: if append=F then it won't add any new lines even if the table is empty
      dbExistsTable: _
    query: >
      rs = dbSendQuery
      df = dbGetQuery
  database/ROracle:
    database_roracle/install: [info, database_roracle/install]
    database_roracle/connection: [info, database_roracle/connection]
  database/RJdbc:
    install.packages("RJDBC")
  database/dbplyr: >
    browseVignettes("dbplyr")
    vignette("dbplyr")
    install.packages("dbplyr")
  database_roracle/install:
    nrm: install.packages("ROracle")
    tutorial:
      http://www.baldwhiteguy.co.nz/technical/index_files/mac-osx-oracle-instantclient.html
    download: >
      instantclient-basic-macos.x64-11.2.0.4.0.zip
      instantclient-sdk-macos.x64-11.2.0.4.0.zip
      instantclient-sqlplus-macos.x64-11.2.0.4.0.zip
      put into ~/tools/oracle/instantclient_11_2
    setup: >
      cd ~/tools/oracle/instantclient_11_2
      ln -s libclntsh.dylib.11.1 libclntsh.dylib
      export PATH=~/tools/oracle/instantclient_11_2:$PATH
    ref: https://docs.oracle.com/cd/E11882_01/install.112/e38228/inst_task.htm#BABHEBIG
      export ORACLE=$HOME/tools/oracle/instantclient_11_2
      export PATH=$ORACLE:$PATH
      export DYLD_LIBRARY_PATH=$ORACLE
      export NLS_LANG=$ORACLE
      export OCI_LIB_DIR=$ORACLE
      export OCI_INC_DIR=$ORACLE/sdk/include
      sqlplus
    install ROracle: >
      http://dba.stackexchange.com/questions/66424/how-to-install-roracle-on-linux
        R CMD INSTALL --configure-args='--with-oci-lib=/Users/mertnuhoglu/tools/oracle/instantclient_11_2 --with-oci-inc=/Users/mertnuhoglu/tools/oracle/instantclient_11_2/sdk/include' ROracle_1.2-2.tar.gz
  database_roracle/connection:
    ex: >
      con <- DBI::dbConnect(RPostgreSQL::PostgreSQL()
        , user = Sys.getenv("SUPER_USER")
        , password = Sys.getenv("SUPER_USER_PASSWORD")
        , dbname = "app"
        , host = "localhost"
        , port = "5432"
      )
      df = DBI::dbGetQuery(con, "SELECT * FROM data.client")
      df
    opt1: >
      drv <- dbDriver("Oracle")
      username = "system"
      password = "..."
      dbname = "52.73.23.191:1521/btgdev"
      con <- dbConnect(drv, user = username, password = password, dbname = dbname)
    opt2: >
      drv <- dbDriver("Oracle")
      username = "system"
      password = "..."
      host = "52.73.23.191"
      port = "1521"
      sid = "btgdev"
      connect.string <- paste( 
        "(DESCRIPTION=",
        "(ADDRESS=(PROTOCOL=tcp)(HOST=", host, 
        ")(PORT=", port, "))", 
        "(CONNECT_DATA=(SID=", sid, ")))", sep = "")
  date/why multiple date classes:
    as.Date: simplest. without times
    chron: handles dates and times but not time zones
    POSIXct, POSIXlt: dates and times with time zones
    POSIXlt: stores a list of day, month, year ...
    POSIXct: stores seconds since unix epoch
    strptime: converts char to POSIXlt
    as.POSIXlt: >
      converts some to POSIXlt 
      if char arg: expects ISO8601 standard format: "2017-12-30"
    as.POSIXct: converts some to POSIXlt
    ftr: use simplest possible
  date/POSIX.ct ve POSIXlt: >
    as.POSIXct("2015-01-01")
    as.POSIXct(df02$validFrom, format = "%d.%m.%Y")
  date/char to POSIX.ct: >
    strptime("20160115", "%Y%m%d")
  date/as.Date: >
    as.Date('1915-6-16')
    as.Date('20170517', format = "%Y%d%m")
  date/format: >
    format(Sys.time(), "%y%m%d%H%M")
      [1] "1907291705"
    format(Sys.time(), "%Y%m%d%H%M")
      [1] "201907291706"
    format(Sys.time(), "%Y%m%d_%H%M")
      [1] "20190729_1706"
    format(Sys.time(), "%Y%m%d_%H%M%S")
      [1] "20190729_170652"
  date/?strptime: >
    z <- strptime("20/2/06 11:16:16.683", "%d/%m/%y %H:%M:%OS")
    strptime("20160115", "%Y%m%d")
    # [1] "2016-01-15 AST"
  date/extract year, mon out of date: >
    as.numeric(format(date1, "%m"))
  date/convert char to date: >
    as.Date( '2012-05-12' )
    as.Date('20140408',"%Y%m%d")
  date/lubridate: >
    month(date1)
    year(date1)
  date/current date: >
    Sys.time()
    Sys.Date()
  date/convert string to time: >
    t
    # [1] "1505" "1825" "1156" "1925" "1055" "1850"
    t %>%
      strptime( format = "%H%M" ) %>%
      strftime( "%H" )
    # [1] "15" "18" "11" "19" "10" "18"
    t %>%
      strptime( format = "%H%M" ) 
    # [1] "2015-09-15 15:05:00 EEST" "2015-09-15 18:25:00 EEST" "2015-09-15 11:56:00 EEST" 
  date/sequence of dates: >
    ## first days of years
    seq(as.Date("1910/1/1"), as.Date("1999/1/1"), "years")
    seq(from = as.Date("1910/1/1"), to = as.Date("1999/1/1"), "day")
    seq(from = as.Date("1910/1/1"), by = "day", length.out = 30)
    seq(as.Date("2016-01-01"), as.Date("2016-01-05"), by=1)
      # "2016-01-01" "2016-01-02" "2016-01-03" "2016-01-04" "2016-01-05"
  date/difference of time:
    ex01: >
      d1 = Sys.Date()
      d2 = as.Date("2017-03-04")
      difftime( d1, d2, units = "days")
    ex02: >
      a = strptime("20160115", "%Y%m%d")
      b = strptime("20160119", "%Y%m%d")
      difftime(a, b, units = "days") 
      # Time difference of -4 days
      difftime(a, b, units = "days") %>% as.double
      # -4
    ex03: >
      mutate( gecikme_gun = 0 - as.double(difftime( strptime(termin_tarihi, "%Y%m%d"), strptime(kesim_tarihi, "%Y%m%d"), units = "days")) )
    kd: >
      t0 = strptime("0000", format = "%H%M")
      difftime(today(), t0)
      difftime(now(), t0)
      difftime(t2, t0)
    note: give units = "hours" to difftime to make it reproducible
  date/increment date by period: >
    d1 = strptime("20170512", "%Y%m%d")
    d2 = d1 + days(1)
    format(d2, "%Y%m%d")
  date/excel date as number to posixct date:
    opt1: 
      readxl::read_excel(path = sevk_emri_file, col_types = c("text", "date", "text", "text", "text", "text", "text", "text", "text", "numeric", "text", "text", "text", "text"))
    opt2:
      as.POSIXct(sem$shipment_date * (60*60*24) , origin="1899-12-30" , tz="GMT")
  file/file name from path: >
    basename("C:/some_dir/a")
    > [1]  "a"
    dirname("C:/some_dir/a")
    >[1] "C:/some_dir"
  file/dir.create: >
    dir.create(path = ... ) # mkdir
    dir.create(path = ..., recursive = T) # mkdir -p
  file/list.files: >
    list.files(path = ".", pattern = NULL, all.files = FALSE,
      full.names = FALSE, recursive = FALSE,
      ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) # ls
  file/dir: >
    dir(path = ".", pattern = NULL, all.files = FALSE,
      full.names = FALSE, recursive = FALSE,
      ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE)
  file/list.dirs: >
    list.dirs(path = ".", full.names = TRUE, recursive = TRUE)
  file/home directory:
    setwd("~")
  file/join-concat paths:
    file.path(dir1, dir2)
  file/file.copy:
    nrm: >
      file.copy(from, to)
      file.copy(from, to, overwrite = recursive, recursive = FALSE,
            copy.mode = TRUE, copy.date = FALSE)
    copy directories:
      file.copy("data/verify", get_transaction_dir_v1(file_name), recursive = T)
  file/file.create:
    file.create(..., showWarnings = TRUE)
  file/file.exists: 
    file.exists(...)
  file/file.remove: 
    file.remove(...)
  file/file.rename:
    file.rename(from, to)
  file/file.append:
    file.append(file1, file2)
  file/file.symlink:
    file.symlink(from, to)
  file/file.link:
    file.link(from, to)
  file/file extension: >
    library("tools")
    file_ext("test.txt")
  fp/purrr:
    install: install.packages("tidyverse")
    fp/reduce: [info, fp/reduce]
  fp/reduce:
    ex: <url:file:///~/Dropbox/mynotes/content/mine/study_assign_kombin_termin.R>
    ex1: >
      # step4: full_join için for loop kullan
      res = evls[[1]]
      for ( i in 2:length(evls) ) {
        res = res %>%
          full_join( evls[[i]], by = "dependent_id" )
      }
      # step5: reduce ile yap
      full_join_by_dependent_id = function( evl1, evl2 ) {
        evl1 %>%
          full_join( evl2, by = "dependent_id" )
      }
      evls %>% reduce( full_join_by_dependent_id )
  fp/generifying a function using functional programming: >
    write_xbrl_data_x_hd = write_array_fun('xbrl_data_x_hd')
    write_list_xbrl_data_x_hd = function(xbrl_data_list) {
      for (i in seq_along(xbrl_data_list)) {
        title = names(xbrl_data_list)[[i]]
        write_xbrl_data_x_hd(xbrl_data_list[[i]], title)
      }
    }
    ->
    write_list_fun = function(file) {
      write_file_fun = write_array_fun(file)
      function(df_l, arg, ...) {
        for (i in seq_along(df_l)) {
          title = names(df_l)[[i]]
          write_file_fun(df_l[[i]], title)
        }
      }
    }
  fp/problem:- how to make a function testable:
    nrm: >
      change its dependencies without changing its definition
      download_company_idx_files(use_cache = use_cache)
    fp/solution 1:- using partials: [info, fp/solution 1:- using partials]
    fp/problem 2:- we have lots of similar test functions. how to abstract commonalities?: "[info, fp/problem 2:- we have lots of similar test functions. how to abstract commonalities?]"
    fp/solution 2:- using higher order function generator for partial: [info, fp/solution 2:- using higher order function generator for partial]
    fp/solution 3:- abstract one more step: [info, fp/solution 3:- abstract one more step]
  fp/solution 1:- using partials: >
    definition
      .download_company_idx_files = function(year, quarter, use_cache = F ) {
        file.names = path_array_company_0000_qtr0_zip(year, quarter)
        for (i in 1:length(file.names)) {
          file.name = file.names[i]
          download.file(url, destfile=file.name, method="wget") #@ > company_0000-qtr0.zip
        }
      }
      download_company_idx_files_real = partial(.download_company_idx_files, year = 2009:year(Sys.Date()), quarter = 1:4)
      download_company_idx_files = download_company_idx_files_real 
    test code
      year = '2014'
      quarter = '4'
      download_company_idx_files_test = partial(.download_company_idx_files, year = year, quarter = quarter)
      download_company_idx_files = download_company_idx_files_test
  fp/problem 2:- we have lots of similar test functions. how to abstract commonalities?: >
    example:
      unzip_company_idx_files_test = partial(.unzip_company_idx_files, year = year, quarter = quarter)
      unzip_company_idx_files = unzip_company_idx_files_test
      convert_idx2csv_test = partial(.convert_idx2csv, year = year, quarter = quarter)
  fp/solution 2:- using higher order function generator for partial: >
    make_test_fun = function(fun) {
      function(year, quarter) {
        partial(fun, year = year, quarter = quarter)
      }
    }
    download_company_idx_files_test = make_test_fun(.download_company_idx_files)
    download_company_idx_files = download_company_idx_files_test(year, quarter)
    unzip_company_idx_files_test = make_test_fun(.unzip_company_idx_files)
    unzip_company_idx_files = unzip_company_idx_files_test(year, quarter)
  fp/solution 3:- abstract one more step: >
    make_test_fun = function(fun, year, quarter) {
      partial(fun, year = year, quarter = quarter)
    }
    download_company_idx_files = make_test_fun(.download_company_idx_files, year, quarter)
  fp/three dots/ellipsis/...:
    arguments <- list(...)
  gis/sf2 sf id=g12298:
    gis/sf:- simple features: [info, gis/sf:- simple features]
    gis/convert to sf: [info, gis/convert to sf]
    gis/sfc:- sf geometry column: [info, gis/sfc:- sf geometry column]
    gis/sfg:- sf geometry object: [info, gis/sfg:- sf geometry object]
    gis/kd:- wkt:- well-known text: [info, gis/kd:- wkt:- well-known text]
    gis/read-write shape files: [info, gis/read-write shape files]
    gis/view sf objects on map: [info, gis/view sf objects on map]
  gis/sf:- simple features:
    dsc: modern tidyverse uyumlu gis kütüphanesi
    eskisi: sp:- spatial
    ref: ~/gdrive/shared/ozguremin_mert/egar/test11_sf01.R
  gis/convert to sf:
    ref: ~/gdrive/shared/ozguremin_mert/egar/test07_sf.R
    kd: >
      world_sp = as(world, "Spatial")
      world_sf = st_as_sf(world_sp)
    ref2: ~/gdrive/shared/ozguremin_mert/egar/test13_convert_lnglat_to_sf.R
    a01: >
      locations <- read_csv("~/codes/rr/intro-to-r/data/locations.csv")
      locations_sf <- st_as_sf(locations, coords = c("lon", "lat"), crs = 4326)
  gis/sfc:- sf geometry column:
    ref3: sfc:- list-column of type simple feature geometry <url:file:///~/gdrive/shared/ozguremin_mert/egar/test11_sf01.R#r=g12296>
    kd: nc_geom <- st_geometry(nc)
  gis/sfg:- sf geometry object:
    a01: 
      ref: ~/gdrive/shared/ozguremin_mert/egar/test11_sf01.R
      kd: >
        x <- st_point(c(1,2))
        p <- rbind(c(3.2,4), c(3,4.6), c(3.8,4.4), c(3.5,3.8), c(3.4,3.6), c(3.9,4.5))
        mp <- st_multipoint(p)
    a02: 
      ref: ~/gdrive/shared/ozguremin_mert/egar/test14_sf_from_scratch.R
      kd: >
        g = st_sfc(st_point(1:2))
        st_sf(a=3,g)
  gis/kd:- wkt:- well-known text:
    ref: ~/gdrive/shared/ozguremin_mert/egar/test11_sf01.R
    kd: >
      x <- st_linestring(matrix(10:1,5))
      st_as_text(x)
        "LINESTRING (10 5, 9 4, 8 3, 7 2, 6 1)"
      st_as_sfc("LINESTRING(10 5, 9 4, 8 3, 7 2, 6 1)")[[1]]
  gis/read-write shape files:
    ref: ~/gdrive/shared/ozguremin_mert/egar/test11_sf01.R
    kd: >
      filename <- system.file("shape/nc.shp", package="sf")
      nc <- st_read(filename)
  gis/view sf objects on map:
    ref: ~/gdrive/shared/ozguremin_mert/egar/test13_convert_lnglat_to_sf.R
    kd: >
      mapview(locations_sf) # opt01
      leaflet(locations_sf) %>% addProviderTiles("OpenStreetMap.Mapnik") %>% addCircles(weight = 20)
  gis/leaflet2 leaflet id=g12297:
    ref: Documentation:- Leaflet for R <url:file:///~/projects/study/r/shiny/study_leaflet.Rmd#r=g12293>
    gis/shiny-leaflet: [info, gis/shiny-leaflet]
    gis/markers: [info, gis/markers]
    gis/Türkiye illerinin poligon haritası: [info, gis/Türkiye illerinin poligon haritası]
  gis/shiny-leaflet:
    gis/leaflet haritasını shiny içine koyma: [info, gis/leaflet haritasını shiny içine koyma]
    gis/Dashboard sidebar ve giriş ekranı: [info, gis/Dashboard sidebar ve giriş ekranı]
    gis/click eventleri: [info, gis/click eventleri]
    gis/map objesini state içine koy. güncellemeler için: [info, gis/map objesini state içine koy. güncellemeler için]
  gis/leaflet haritasını shiny içine koyma:
    ref: ~/projects/study/r/shiny/ex/study_leaflet/leaflet_shiny/e01.R
    ui:
      leafletOutput("mymap", height = "700px"),
    server: >
      output$mymap <- renderLeaflet({
        leaflet() %>%
  gis/Dashboard sidebar ve giriş ekranı:
    ref: ~/projects/study/r/shiny/ex/study_leaflet/ex02/01.R
    ui: >
      dashboardBody(
        leafletOutput("map")
    server:
      output$map <- renderLeaflet({
  gis/click eventleri:
    ref: Inputs/Events <url:file:///~/projects/study/r/shiny/study_leaflet.Rmd#r=g12294>
    a01: 
      ref: ~/projects/study/r/shiny/ex/study_leaflet/ex02/02.R
      ui: >
        map <- leaflet() %>% addCircleMarkers(
          layerId = paste0("marker", 1:10), ...)
      server:
        observeEvent(input$map1_marker_click, {
          leafletProxy("map1", session) %>%
            removeMarker(input$map1_marker_click$id)
    a02: 
      ref: ~/gdrive/shared/ozguremin_mert/egar/test15_click_in_leaflet01.R
      kd: >
        observe({
          click<-input$map_marker_click
          if(is.null(click)) return()
          map$showPopup( click$lat, click$lng, "text")
          output$Click_text <- renderText({ text2 }) # debug
  gis/map objesini state içine koy. güncellemeler için:
    ref: ~/projects/study/r/shiny/ex/study_leaflet/ex02/03.R
    server: >
      state = reactiveValues( map = make_map())
      output$map1 = renderLeaflet(state$map)
  gis/markers:
    gis/text kullan pin marker içinde: [info, gis/text kullan pin marker içinde]
    gis/remove marker: [info, gis/remove marker]
    gis/sadece label'dan oluşan marker: [info, gis/sadece label'dan oluşan marker]
    gis/marker olarak resim kullanmak: [info, gis/marker olarak resim kullanmak]
  gis/text kullan pin marker içinde:
    ref: ~/projects/study/r/shiny/ex/study_leaflet/ex01/04.R
    kd: icon.fa <- makeAwesomeIcon(text = 1)
  gis/remove marker:
    ref: ~/projects/study/r/shiny/ex/study_leaflet/ex01/06.R
    dsc: önce layerId ile oluştur, sonra onunla sil
    kd: >
      leaflet() %>% addTiles() %>%
        addMarkers( layerId = "2", lng = -118.556554, lat = 34.078039, label = "red" ) %>%
        removeMarker( layerId = "2" )
  gis/sadece label'dan oluşan marker:
    ref: ~/gdrive/shared/ozguremin_mert/egar/test01_label.R
    kd: >
      addLabelOnlyMarkers(data = centers,
        lng = ~x, lat = ~y, label = ~region,
        labelOptions = labelOptions(noHide = TRUE, direction = 'top', textOnly = TRUE)) %>%
  gis/marker olarak resim kullanmak:
    ref: ~/gdrive/shared/ozguremin_mert/egar/test06_icons.R
    kd: addMarkers(~long, ~lat, icon = leafIcons)
    a01: 
      leafIcons <- icons(
        iconUrl = ifelse(quakes1$mag < 4.6,
                         "http://leafletjs.com/examples/custom-icons/leaf-green.png",
                         "http://leafletjs.com/examples/custom-icons/leaf-red.png"
  gis/Türkiye illerinin poligon haritası: >
    library(rgdal)
    library(leaflet)
    file =  "ne_50m_admin_0_countries.zip"
    download.file(file.path('http://www.naturalearthdata.com/http/',
        'www.naturalearthdata.com/download/50m/cultural',
        'ne_50m_admin_0_countries.zip'), 
        destfile = file)
    unzip(file)
    world <- readOGR(tempdir(), 'ne_50m_admin_0_countries', encoding='UTF-8')
    leaflet() %>%
      addTiles() %>%
      addPolygons(data=subset(world, name %in% "Turkey"), weight=2)
  io/rio: >
    install.packages("rio")
    library("rio")
    ev = import("data/enum_value.csv")
    export(ev, "data/enum_value.tsv")
    ev2 = import("data/enum_value.tsv")
    all.equal(ev, ev2, check.attributes = F)
    convert("data/enum_value.csv", "data/enum_value.tsv")
    # Rscript -e "rio::convert('data/enum_value.csv', 'data/enum_value.tsv')"
    Rscript -e "rio::convert('$FILE', '$FILE.xlsx')"
  io/csv: >
    dt = fread(file) 
    read.csv(filename, header=T)   
    write.csv(df, file)
    read.csv(text = "..")
      csv = 'id,size
      1,100
      2,150'
      read.csv(text = csv)
  io/fread arguments: >
    skip
      skip = "string"
        search "string" start on that line
      skip = 10
        skip first 10 lines
    select = cols # columns to keep
    drop = cols # column names to drop
    fread(url) # read url directly
    fread(string) # read string directly
  io/readLines writeLines - text: >
    text = readLines( file )
    writeLines(lines, "names_stats.txt")
    readLines(con <- file("Unicode.txt", encoding = "UCS-2LE"))
  io/read.csv args: >
    na.strings = c("foo", "bar") # custom NA labels
    header = T
    sep = ","
    read.csv(file, header = TRUE, sep = ",", quote = "\"",
      dec = ".", fill = TRUE, comment.char = "", ...)
    read.delim(file, header = TRUE, sep = "\t", quote = "\"",
      dec = ".", fill = TRUE, comment.char = "", ...)
    read.csv(paste0(raw_data_dir, file), stringsAsFactors = FALSE)
  io/readr:
    io/delimited: read_delim(), read_csv(), read_tsv(), read_csv2().
    io/fixed width: read_fwf(), read_table().
    io/lines: read_lines().
    io/whole file: read_file().
    io/write: write_csv()
    io/points - readr: [info, io/points - readr]
  io/points - readr:
    io/read_csv sparse kolonlarda tipleri yanlış tanıyabiliyor id=g10656: [info, io/read_csv sparse kolonlarda tipleri yanlış tanıyabiliyor id=g10656]
    io/disable scientific notation in write_csv  id=g10657: [info, io/disable scientific notation in write_csv  id=g10657]
    write_csv(na = ""): don't forget NA id=g10658
  io/read_csv sparse kolonlarda tipleri yanlış tanıyabiliyor id=g10656:
    bug:
      ref: <url:/Users/mertnuhoglu/projects/bizqualify/BQ-data-run/datarun/debug_missing_data_20181027.md#tn=CONTEXT>
      dsc: >
        örneğin çok fazla NA olan satırları character olarak algılıyor. (bq_cogs)
        halbuki bq_cogs numeric
        bu yüzden 359e4 gibi bilimsel notasyonnda yazılmış numerik değerleri çeviremiyorum: options(scipen=999) ile
        bu yüzden postgresql copy from csv hata veriyor
  io/disable scientific notation in write_csv  id=g10657:
    opt01: >
      scipen
      options(scipen = 999)
    opt02: as.character
  io/excel2 excel readxl:
    ref: 
      ex01: Farklı sayfalardaki tabloları birleştir <url:file:///~/projects/study/r/examples_r.Rmd#r=g12544>
      ex02: Farklı sayfaları/sheets sıraya  dizelim <url:file:///~/projects/study/r/examples_r.Rmd#r=g12545>
    ex01: >
      readxl::read_excel("my-spreadsheet.xls", sheet = "data")
      readxl::read_excel("egar_gis_db.xlsx", sheet = "bolgeler")
    link içeren excel dosyaları: >
      bir excel dosyası başka bir dosyaya link içerdiğinde, "update links" demek gerekiyor
      aksi taktirde eski veriler okunur
    list all sheets:
      sheet_names = readxl::excel_sheets(piid)
  io/write excel:
    opt1:- openxlsx:- no external dependency: >
      library(openxlsx)
      write.xlsx( r, "temp3.xlsx" )
      write.xlsx( r, "temp4.xlsx", asTable = T)
      write.xlsx( r, "temp.xlsx", sheetName = "storyboard2", append = T )
      write.xlsx( r, "temp.xlsx", sheetName = "storyboard3", append = T )
      write.xlsx( r, "rdb_mockups.xlsx", sheetName = "storyboard3", append = T )
    opt2:- xlsx:- uses java apache poi: >
      library(xlsx)
      write.xlsx(report, 'view_open_problems.xlsx', row.names = F)
    opt3: >
      ## Lists elements are written to individual worksheets, using list names as sheet names if available
      l <- list("IRIS" = iris, "MTCATS" = mtcars, matrix(runif(1000), ncol = 5))
      write.xlsx(l, "writeList1.xlsx")
  io/read.table: >
    read.table(file, header = FALSE, sep = "", quote = "\"'",
      dec = ".", numerals = c("allow.loss", "warn.loss", "no.loss"),
      row.names, col.names, as.is = !stringsAsFactors,
      na.strings = "NA", colClasses = NA, nrows = -1,
      skip = 0, check.names = TRUE, fill = !blank.lines.skip,
      strip.white = FALSE, blank.lines.skip = TRUE,
      comment.char = "#",
      allowEscapes = FALSE, flush = FALSE,
      stringsAsFactors = default.stringsAsFactors(),
      fileEncoding = "", encoding = "unknown", text, skipNul = FALSE)
  io/openxlsx: >
    read.xlsx(xlsxFile, sheet = 1, startRow = 1, colNames = TRUE, 
      rowNames = FALSE, detectDates = FALSE, skipEmptyRows = TRUE, 
      rows = NULL, cols = NULL, check.names = FALSE, namedRegion = NULL)
  io/google spreadsheets:
    ref: https://github.com/tidyverse/googlesheets4
    install: >
      install.packages("devtools")
      devtools::install_github("tidyverse/googlesheets4")
    googlesheets: https://cran.r-project.org/web/packages/googlesheets/vignettes/basic-usage.html
  io/convention:- export(.., na = ""): >
    always export, write csv files where na = ""
    because java DataFrame doesn't read rows with "NA" when the columns are numeric
  json/jsonlite: >
    tercih
    doğrudan df olarak döndürüyor
  json/jsonlite örnek: >
    jsonlite::toJSON(obj)
    result = jsonlite::fromJSON("data/input/postman_20160719.json")
    jsonlite::fromJSON("data/arcgis/aws.json", simplifyDataFrame = T)
      df üretir, bazen
  json/rjson: >
    result = rjson::fromJSON(file="data/input/postman_20160719.json")
  json/ex01: >
    all.equal(mtcars, fromJSON(toJSON(mtcars)))
  json/ex02: >
    emdkj = jsonlite::fromJSON("data/arcgis/emdk.json")$services
    # direk df döndü
  json/call rest api:
    ref: https://cran.r-project.org/web/packages/jsonlite/vignettes/json-apis.html
    base: hadley_orgs <- fromJSON("https://api.github.com/users/hadley/orgs")
    response: >
      json [{..}, {..}]
      ->
      dataframe
    ex: >
      [
        {
          "login": "ggobi",
          "id": 423638,
          "url": "https://api.github.com/orgs/ggobi",
          "repos_url": "https://api.github.com/orgs/ggobi/repos",
          "events_url": "https://api.github.com/orgs/ggobi/events",
          "hooks_url": "https://api.github.com/orgs/ggobi/hooks",
          "issues_url": "https://api.github.com/orgs/ggobi/issues",
          "members_url": "https://api.github.com/orgs/ggobi/members{/member}",
          "public_members_url": "https://api.github.com/orgs/ggobi/public_members{/member}",
          "avatar_url": "https://avatars2.githubusercontent.com/u/423638?v=3",
          "description": ""
        },
      ->
      hadley_orgs %>% s
      'data.frame'
       $ login             
       $ id                
       $ url               
       $ repos_url         
       $ events_url        
       $ hooks_url         
       $ issues_url        
       $ members_url       
       $ public_members_url
       $ avatar_url        
       $ description       
  json/ex03: 
    ref: http://juliasilge.com/blog/Mapping-Utah-Caucus/
    kd: >
      library(jsonlite)
      utahRJSON <- fromJSON("http://data.cnn.com/ELECTION/2016primary/UT/county/S.json", flatten=TRUE)
      cruz <- mutate(map_df(utahRJSON$counties$race.candidates, function(x) {
          x %>% filter(lname == "Cruz")
        }), FIPS=utahRJSON$counties$countycode)
  json/yaml: >
    library('yaml')
    install.packages('yaml')
    install_github("MangoTheCat/rematch")
    yaml.load(aString)
    yaml.load_file(apath)
    as.yaml(obj)
  magrittr/basic: >
    x %>% f === f(x)
    x %>% f(y) === f(x,y)
    x %>% f %>% g === g(f(x))
  magrittr/argument placeholder: >
    x %>% f(y, .) === f(y,x)
  magrittr/reusing placeholder: >
    x %>% f(y = nrow(.)) === f(x, y = nrow(x))
    overrule this by enclosing in braces
    x %>% {f(y = nrow(.))} === f(y = nrow(x))
  magrittr/unary function: >
    f <- . %>% cos %>% sin # ==
    f <- function(.) sin(cos(.)) 
  magrittr/create functions (or functional sequences):
    magrittr.functional_sequence/kd: [info, magrittr.functional_sequence/kd]
    magrittr.functional_sequence/ex: [info, magrittr.functional_sequence/ex]
    magrittr.functional_sequence/rules: [info, magrittr.functional_sequence/rules]
    magrittr.functional_sequence/exception: [info, magrittr.functional_sequence/exception]
    magrittr.functional_sequence/ex2:- remove na records: [info, magrittr.functional_sequence/ex2:- remove na records]
    magrittr.functional_sequence/ex3:- mutate some columns: [info, magrittr.functional_sequence/ex3:- mutate some columns]
  magrittr.functional_sequence/kd: >
    mae <- . %>% abs %>% mean(na.rm = TRUE)
    mae(rnorm(10))
    #> [1] 0.5605
  magrittr.functional_sequence/ex: >
    n1 = lapply(filenames,
      . %>% nchar )
    n2 = filenames %>% 
      lapply( . %>% nchar )
    n3 = filenames %>% 
      lapply(function(x) nchar(x))
    n4 = filenames %>% 
      lapply(., function(x) nchar(x))
  magrittr.functional_sequence/rules: >
    if dot is used, then first arg is not passed automatically
    if dot is used as lambda, then first arg is still passed
  magrittr.functional_sequence/exception:
    works:
      lapply(x, . %>% {ifelse(is.blank(.),NA,.)} )
    fails:
      lapply(x, . %>% ifelse(is.blank(.),NA,.) )
    lesson:
      if using dot as inner arg, then first arg is automatically passed
  magrittr.functional_sequence/ex2:- remove na records:
    opt1:- works: >
      df = data.frame( id = c(1, 2, NA) )
      r1 = dplyr::filter( df, !is.na(df$id) )
    opt2:- doesn't work: >
      r2 = df %>%
        filter( !is.na(.$id) )
    opt3:- works: >
      r3 = df %>>%
        (dplyr::filter(., !is.na(.$id) ))
  magrittr.functional_sequence/ex3:- mutate some columns:
    opt1: >
      df = data.frame( id = c(1, 2, NA) )
      as.character(df$id)
    opt2: >
      r2 = df %>%
        mutate( id = as.character(id) )
  magrittr/alias: >
    equals add multiply_by
    extract [
      ecd %>% extract("independent_id")
    extract2 [[
    use_series $
      ecd %>% use_series("independent_id")
    ‘extract’                 ‘`[`’
    ‘extract2’                ‘`[[`’
    ‘inset’                   ‘`[<-`’
    ‘inset2’                  ‘`[[<-`’
    ‘use_series’              ‘`$`’
    ‘add’                     ‘`+`’
    ‘subtract’                ‘`-`’
    ‘multiply_by’             ‘`*`’
    ‘raise_to_power’          ‘`^`’
    ‘multiply_by_matrix’      ‘`%*%`’
    ‘divide_by’               ‘`/`’
    ‘divide_by_int’           ‘`%/%`’
    ‘mod’                     ‘`%%`’
    ‘is_in’                   ‘`%in%`’
    ‘and’                     ‘`&`’
    ‘or’                      ‘`|`’
    ‘equals’                  ‘`==`’
    ‘is_greater_than’         ‘`>`’
    ‘is_weakly_greater_than’  ‘`>=`’
    ‘is_less_than’            ‘`<`’
    ‘is_weakly_less_than’     ‘`<=`’
    ‘not’ (‘`n'est pas`’)     ‘`!`’
    ‘set_colnames’            ‘`colnames<-`’
    ‘set_rownames’            ‘`rownames<-`’
    ‘set_names’               ‘`names<-`’
  magrittr/map function:
    equvalent: >
      lapply( rownames %>% {. %>% partial( path_array_exchange_listing_x, . )})
      rownames %>% { partial( path_array_exchange_listing_x, . ) }
      rownames %>% partialm(path_array_exchange_listing_x)
  magrittr/argument placeholder2:
    x %>% f(y, .) === f(y,x)
  magrittr/stepwise string-cleaning: >
    files %<>%
      basename %>%
      str_replace("...", "") %>%
      str_replace("...", "")
  magrittr/paste: >
    "this" %>% paste("is not") %>% paste("a pipe")
  magrittr/ex01: 
    ref: https://twitter.com/isthatsol/status/557981863432564739
    kd: >
      foo_foo %>%
        hop_through(forest) %>%
        scoop_up(field_mouse) %>%
        bop_on(head)
  magrittr/assign and str:
    x = x %T>% str
  magrittr/using operations instead of aliases: >
    x %>% .[3] %>% `+`(3)
    setnames
      `names<-`
      `colnames<-`
      `rename
  magrittr/tee:- return lhs: >
    matrix(ncol = 2) %T>%
      plot %>%
      colSums
  magrittr/exposition of variables: >
    iris %$% cor(Sepal.Length, Sepal.Width)
  magrittr/define function on fly: >
    long_vector %>%
    lapply(
      . %>%
      one_action %>%
      two_action
    )
  magrittr/lambdas (unary function): >
    iris %>% 
      {
        n = sample(1:10, size = 1)
        H = head(., n)
        T = tail(., n)
        rbind(H, T)
      } %>%
  magrittr/examples: >
    x[!is.na(x)] # equivalent in pipe where x is any vector.
    x %>% '['(is.na(.) %>% '!')
  magrittr/pipe examples:
    make_na: >
        filename %>% root_xbrl %>>% (x ~ NA),
        filename %>% root_xbrl %>>% function(x) NA,
    detect filename that causes error: >
      filenames %>% l_ply(. %T>% print %>% root_xbrl2, .progress = "text")
  R_platform/library install.packages update upgrade install_github: >
    library("devtools")
    library(updateR)
    install.packages("devtools")
    install_github("repo/username")
    devtools::install_github("AndreaCirilloAC/updateR")
    updateR(admin_password = '<pass>') 
  R_platform/update all packages from CRAN:
    update.packages(checkBuilt=TRUE, ask=FALSE)
  R_platform/Performance:
    measure time:
      system.time(for(i in 1:100) mad(runif(1000)))
    profiling: >
      Rprof('file')
      # code
      Rprof(NULL)
      summaryRprof('file')
  R_platform/System:
    R_platform.system/ex01: [info, R_platform.system/ex01]
    R_platform.system/ex02: [info, R_platform.system/ex02]
    R_platform.system/ex03: [info, R_platform.system/ex03]
    R_platform.system/ex04: [info, R_platform.system/ex04]
    R_platform.system/calling R from shell: [info, R_platform.system/calling R from shell]
    R_platform.system/taking argument in R scripts: [info, R_platform.system/taking argument in R scripts]
  R_platform.system/ex01: >
    system(cmd)
  R_platform.system/ex02: >
    system(cmd, intern=T) # capture output of command 
  R_platform.system/ex03: >
    system2("echo", "hello")
  R_platform.system/ex04: >
    output = system2(main_yuml_to_uml.sh, data_model_dir, stdout=TRUE) # capture output of command 
  R_platform.system/calling R from shell:
    bash:
      Rscript RscriptEcho.R study_rscript1.R test 10
    study_rscript1.R: >
      #! /usr/bin/Rscript --vanilla --default-packages=utils
      args <- commandArgs(TRUE)
      print(args)
  R_platform.system/taking argument in R scripts: >
    args <- commandArgs(trailingOnly = TRUE)
    print(args)
  R_platform/initial/startup/default session settings: >
    ~/.Rprofile
  R_platform/options/settings: >
    options(max.width=100)
    GetOption("max.width")
    options(max.print=100)
    options(max.print=6)
  R_platform/packages2:- usethis:
    ref:
      packages2: packagesr packager <url:file:///~/projects/study/otl/cr_archived.otl#r=g12292>
    R_platform.packages/usethis: [info, R_platform.packages/usethis]
  R_platform.packages/usethis:
    ref: https://www.tidyverse.org/articles/2017/11/usethis-1.0.0/
    R_platform.packages/install: [info, R_platform.packages/install]
    R_platform.packages/Create a new package: [info, R_platform.packages/Create a new package]
    R_platform.packages/create/edit a script file in R/: [info, R_platform.packages/create/edit a script file in R/]
    R_platform.packages/unit testing: [info, R_platform.packages/unit testing]
    R_platform.packages/dependency/library: [info, R_platform.packages/dependency/library]
    R_platform.packages/use_roxygen_md(): [info, R_platform.packages/use_roxygen_md()]
    R_platform.packages/use_package_doc(): [info, R_platform.packages/use_package_doc()]
    R_platform.packages/use_readme_rmd(): [info, R_platform.packages/use_readme_rmd()]
    R_platform.packages/use_news_md(): [info, R_platform.packages/use_news_md()]
    R_platform.packages/use_vignette("vignette-name"): [info, R_platform.packages/use_vignette("vignette-name")]
    R_platform.packages/licenses: [info, R_platform.packages/licenses]
    R_platform.packages/init git: [info, R_platform.packages/init git]
    R_platform.packages/publish to github: [info, R_platform.packages/publish to github]
    R_platform.packages/browsing config files: [info, R_platform.packages/browsing config files]
  R_platform.packages/install:
    install.packages("usethis")
    library(usethis)
  R_platform.packages/Create a new package: >
    tmp <- file.path(tempdir(), "mypkg")
    create_package(tmp)
    #> Changing active project to mypkg
    #> ✔ Creating 'R/'
    #> ✔ Creating 'man/'
    #> ✔ Writing 'DESCRIPTION'
    #> ✔ Writing 'NAMESPACE'
  R_platform.packages/create/edit a script file in R/:
    use_r("foo")
    #> ● Edit 'R/foo.R'
  R_platform.packages/unit testing: >
    use_test("foo")
    #> ✔ Adding 'testthat' to Suggests field in DESCRIPTION
    #> ✔ Creating 'tests/testthat/'
    #> ✔ Writing 'tests/testthat.R'
    #> ✔ Writing 'tests/testthat/test-foo.R'
    #> ● Edit 'tests/testthat/test-foo.R'
  R_platform.packages/dependency/library:
    kd: >
      use_package("ggplot2")
      #> ✔ Adding 'ggplot2' to Imports field in DESCRIPTION
      #> ● Refer to functions with `ggplot2::fun()`
    opt:
      use_dev_package()
  R_platform.packages/use_roxygen_md():
    sets up roxygen2 and enables markdown mode 
  R_platform.packages/use_package_doc():
    creates a skeleton documentation file for the complete package
  R_platform.packages/use_readme_rmd():
    creates a README.Rmd
  R_platform.packages/use_news_md():
    creates a basic NEWS.md 
  R_platform.packages/use_vignette("vignette-name"):
    sets you up for success by configuring DESCRIPTION and creating a .Rmd template in vignettes/
  R_platform.packages/licenses: >
    use_mit_license("Mert Nuhoglu")
    use_apl2_license()
    use_gpl3_license()
    use_cc0_license()
  R_platform.packages/init git: >
    use_git()
    #> ✔ Initialising Git repo
    #> ✔ Adding '.Rhistory', '.RData', '.Rproj.user' to './.gitignore'
    #> ✔ Adding files and committing
  R_platform.packages/publish to github:
    use_github()
  R_platform.packages/browsing config files:
    R: >
      edit_r_profile()
      edit_r_environ()
      edit_r_makevars()
    git: >
      edit_git_config()
      edit_git_ignore()
  rep/base: a2 = data_frame( id = 5:7 )
  rep/ex01: >
    a3 = a2 %>%
      slice( rep(1:n(), each = 2)) %>%
      mutate( col = rep(1:2, each = 3) )
    #      id   col
    #   <int> <int>
    # 1     5     1
    # 2     5     1
    # 3     6     1
    # 4     6     2
    # 5     7     2
    # 6     7     2
  rep/ex02: >
    replicate(3, 1:2, simplify=F) %>% unlist
    # [1] 1 2 1 2 1 2
  rep/ex03: >
    a4 = a2 %>%
      slice( rep(1:n(), each = 2)) %>%
      mutate( col = unlist(replicate(3, 1:2, simplify = F)) )
    #      id   col
    #   <int> <int>
    # 1     5     1
    # 2     5     2
    # 3     6     1
    # 4     6     2
    # 5     7     1
    # 6     7     2
  rep/ex04: 
    elems = 1:2
    a5 = a2 %>%
      slice( rep(1:n(), each = length(elems))) %>%
      mutate( col = unlist(replicate(n()/length(elems), elems, simplify = F)) )
  rep/ex05: >
    a6 = a2 %>%
      mutate_looping(elems, "col")
  rep/ex06:
    ref: rep/ex06 <url:file:///~/projects/study/r/examples_r.Rmd#r=g12623>
    kd: >
      v1 <- c(1,4,8)
      rep(v1,c(3,1,2))
      ##> [1] 1 1 1 4 8 8
  reproducible/reprex:- reproducible example codes:
    install:
      install.packages("reprex")
      library(reprex)
    ref: http://reprex.tidyverse.org
    opt1:- copy some code into clipboard:
      nrm: reprex()
      ex: >
        (y <- 1:4)
        mean(y)
      out: >
        ``` r
        (y <- 1:4)
        #> [1] 1 2 3 4
        mean(y)
        #> [1] 2.5
        ```
    opt2:- from expression: >
      reprex(mean(rnorm(10)))
    opt3:- from character vector: >
      reprex(input = "mean(rnorm(10))\n")
      reprex(input = "> mean(rnorm(10))\n")
    opt4:- from file: >
      reprex(input = "my_reprex.R") 
    opt5:- RStudio addin text:
      for stackoverflow:
        reprex(..., venue = "so")
      for runnable R script:
        reprex(..., venue = "R")
  reproducible/datapasta:
    ref: >
      <url:file:///~/projects/study/r/refcard_datapasta.Rmd>
      https://github.com/MilesMcBain/datapasta
    install:
      install.packages("datapasta")
    copy paste table/vector data:
      ex terminal: >
        library(magrittr); library(datapasta)
        mtcars %>% head() %>% dpasta()
        #> data.frame(
        #>          mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1),
        #>          cyl = c(6, 6, 4, 6, 8, 6),
        #>         disp = c(160, 160, 108, 258, 360, 225),
        #> )
      ex:- copy table from excel:
        df_paste()
    functions: >
      dpasta()
      dmdclip() # for md. preceded by 4 spaces
      tribble_paste()
      vector_paste()
      vector_paste_vertical()
  rmarkdown/install: >
    install.packages("rmarkdown")
    library("rmarkdown")
  rmarkdown/run: >
    rmarkdown::render("input.Rmd")
    render("input.Rmd", "pdf_document")
  rmarkdown/Presenter Mode: >
    add this to the end of the url while starting
    ?presentme=true
    /Users/mertnuhoglu/projects/dewey/data_analysis_presentations/istanbulcoders/input.html?presentme=true
  rmarkdown/adding to slides: >
    <div class="notes">
    this is notes
    </div>
  rstudio/custom shortcuts: >
    #F12  go to file/function
    #B    go to function definition
    ^O    navigate back
  rstudio/View() Rstudio: >
    planes %>% filter(no.seats < 10) %>% View()
  sequence/rep(x, ntimes): >
    rep(c(0, 5), times=c(3, 2)) # 0 0 0 5 5 
    rep(c(0, 5), c(3, 2)) # 0 0 0 5 5 
    rep(c(0, 5), each=4) # 0 0 0 0 5 5 5 5
  sequence/gl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE): >
    gl(2, 1, 6) ##> [1] 1 2 1 2 1 2
    gl(3, 2, 6) ##> [1] 1 1 2 2 3 3
  sequence/replicate(n, expr): >
    replicate(5, sample(1:10, 15, replace = T), simplify = F)
      list of 5 vectors with 15 numbers
    simplify=T # dataframe of 15 rows 5 columns
    unlist(..) # 75 numbers
  shiny/install:
    install.packages("shiny")
  shiny/ref: >
    ~/projects/study/r/shiny/shiny_reactivity.md
    ~/projects/study/r/shiny/study_shiny.Rmd
  shiny/shiny examples:
    ref: >
      ~/projects/study/r/shiny/ref_shiny_examples.txt
      https://github.com/rstudio/shiny-examples
      https://shiny.rstudio.com/gallery/#demos
  shiny/örnek projelerim: >
    ~/gdrive/shared/ozguremin_mert/egar/egar07.R
    ~/projects/itr/peyman/pmap/R/route_navigator.R
    ~/projects/itr/vrp/vrprapi/app/server.R
    ~/projects/itr/palet/dentas_palet/app/server.R
    ~/projects/itr/peyman/pmap/doc/study/ex/leaflet_rota_cizimi_20190530/ex33d03.R
    ~/projects/study/r/shiny/ex/study_shiny/ex03/01.R
  shiny/run:
    ex01: >
      runApp("shinyScript.R")
    ex02: >
      runApp(shinyApp(ui, server), host="0.0.0.0",port=5050)
        host parametresi verirsen tüm her yerden bağlanabilirsin. 
        ref: ~/projects/itr/peyman/pmap/doc/study/ex/leaflet_rota_cizimi_20190530/ex15.R
        https://stackoverflow.com/questions/26799722/hosting-and-setting-up-own-shiny-apps-without-shiny-server
    ex03: >
      app = shiny::shinyApp(ui, server)
      runApp(app)
  shiny/publishing to shinyapps.io: >
    shinyapps.io/admin
    new domain name
    authorize account
    library(rsconnect)
    rsconnect::deployApp('path/to/your/app')
      rsconnect::deployApp('shiny/lesson01')
  shiny/conf:
    location:
      site_dir:
        folder where multiple apps are stored in each folder
      app_dir:
        only one application
      ex: >
        # Define the location '/specialApp'
        location /specialApp {
          # Run this location in 'app_dir' mode, which will host a single Shiny
          # Application available at '/srv/shiny-server/myApp'
          app_dir /srv/shiny-server/myApp
        }
        # Define the location '/otherApps'
        location /otherApps {
          # Run this location in 'site_dir' mode, which hosts the entire directory
          # tree at '/srv/shiny-server/apps'
          site_dir /srv/shiny-server/apps;
        }
  shiny/login ekranı:- shinyauthr:
    ref: >
      login ekranı <url:file:///~/projects/study/r/shiny/study_shiny.Rmd#r=g12312>
      ~/projects/study/r/shiny/ex/study_shiny/shinyauthr/e02_shinydashboard.R
  shiny/form fields id=g12301:
    shiny.form/ref: [info, shiny.form/ref]
    shiny.form/widgets: [info, shiny.form/widgets]
    shiny.form/inputWidget -> render -> outputWidget: [info, shiny.form/inputWidget -> render -> outputWidget]
    shiny.form/inputWidget -> observe(state$val <- input$id ) -> output: [info, shiny.form/inputWidget -> observe(state$val <- input$id ) -> output]
    shiny.form/button -> output: [info, shiny.form/button -> output]
  shiny.form/ref: >
    Form Field Examples <url:file:///~/projects/study/r/shiny/shiny_reactivity.md#r=g12299>
    ~/projects/study/r/shiny/ex/shiny_reactivity/form_fields/e02.R
  shiny.form/widgets:
    ref: >
      ~/projects/study/r/shiny/ex/shiny_reactivity/form_fields/e01.R
      https://shiny.rstudio.com/reference/shiny/1.6.0/
      ~/projects/study/r/shiny/ex/shiny_reactivity/form_fields/e03_table.R
    kd: >
      numericInput("obs", "Numeric:", 10),
      textInput("obsText", "Text:", 10),
      textAreaInput("obsTextArea", "Text Area:", 10),
      checkboxInput("obsCheck", "checkbox", FALSE),
      dateInput("obsDate", "date", FALSE),
      selectInput("obsSelect", "select", c("Long Value 01" = "v01", "Long Value 02" = "v02", "Long Value 03" = "v03")),
  shiny.form/inputWidget -> render -> outputWidget:
    ref:
      ~/projects/study/r/shiny/ex/shiny_reactivity/form_fields/e01.R
    kd: >
      numericInput("obs", "Numeric:", 10),
      verbatimTextOutput("print"),
      output$print = renderPrint({ input$obs })
  shiny.form/inputWidget -> observe(state$val <- input$id ) -> output:
    ref:
      ~/projects/study/r/shiny/ex/shiny_reactivity/form_fields/e02.R
    kd: >
      numericInput("obs", "Numeric:", 10),
      verbatimTextOutput("obs4"),
      state <- shiny::reactiveValues( obs3 = 0, obs4 = 0)
      observe({ state$obs4 <- input$obs })
      output$obs4 = renderPrint({ state$obs4 })
  shiny.form/button -> output:
    kd: actionButton("button", "Show")
    opt01: 
      ttl: observeEvent
      ref: ~/projects/study/r/shiny/ex/shiny_reactivity/api/e03_observeEvent.R
      kd: observeEvent(input$button, { cat("Showing", input$x, "rows\n") })
    opt02: 
      ttl: render + isolate
      ref: ~/projects/study/r/shiny/ex/shiny_reactivity/art01/e03.R
      kd: >
        output$distPlot <- renderPlot({
          input$goButton
          dist <- isolate(rnorm(input$obs))
          hist(dist)
        })
  sort/sort-order difference:
    order(symbols):
      1 2 3   # indexes
    sort(symbols):
      A  AA AA^  # actual values
  sort/dataframe:
    a01: >
      df[ order(df$B), ]  
    a02: >
      df[ rev(order(df$B)), ] # reverse order
  sort/data table:
    a01: >
      dt[order(x,y))
    a02: >
      dt[order(-rank(x),y)) # no dt$col since dt is an environment
  string/stringi:
    transliterate: _
    totitle case: >
      label %>%
        str_replace_all( "_", " " ) %>%
        stri_trans_totitle( locale = "tr_TR" )
  string/substring:
    a01: >
      substring("ahmet", 1, 3)
    a02: >
      substring("ahmet", 1, 3:5)
    a03:- remove last n chars: >
      substr(x, 1, nchar(x) - n)
  string/string templating:
    string.sprintf/sprintf: [info, string.sprintf/sprintf]
    string.sprintf/leading zeros: [info, string.sprintf/leading zeros]
    string.sprintf/escaping percent: [info, string.sprintf/escaping percent]
    string.sprintf/sprintf:- arguments cannot be recycled to the same length: [info, string.sprintf/sprintf:- arguments cannot be recycled to the same length]
    string.sprintf/named placeholders: [info, string.sprintf/named placeholders]
  string.sprintf/sprintf:
    a01: >
      sprintf("Filings: %d", nrow(hfs) )
    a02: >
      sprintf("Filings: %f", 7.2 )
    a03:- out of order: >
      sprintf("%2$s %1$s", "hello", "world")
  string.sprintf/leading zeros:
    a01: >
      sprintf("%03s", 1:end)
    a02: >
      > sprintf("%05d", 1:3)
      [1] "00001" "00002" "00003"
  string.sprintf/escaping percent: >
    sprintf("%s escape %%that", "ali")
  string.sprintf/sprintf:- arguments cannot be recycled to the same length:
    problem: >
      sprintf( "%s/QTR%s", as.character(year), as.character(quarter) )
      year and quarter cannot be recycled
    cross join and using dataframe with sprintf:
      opt03:- by = character(): >
        band_members
        df_uppercase = data.frame( case = c("upper", "lower") )
        band_members %>%
          dplyr::full_join(df_uppercase, by = character())
      opt01:- data.table::CJ: >
        df = CJ(year, quarter)
        sprintf("%s,%s",df$V1, df$V2)
      opt02:- dummy column: >
        cust_time$k <- 1
        cust_time %>% 
          inner_join(cust_time, by='k') %>%
          select(-k)
  string.sprintf/named placeholders:
    gsubfn: >
      library("gsubfn")
      df = data.frame( id = 1:3, eroziya = 5:7 )
      '%(id)s: %(eroziya)d' %format% df
      #[1] "1: 5" "2: 6" "3: 7"
  string/paste (concat concatenate):
    na'leri blank ile replace et: >
      > na.exclude(c(NA, 3)) %>% as.character
      [1] "3"
    concat = paste: >
      paste("q", 1:5, sep="") 
      [1] "q1" "q2" "q3" "q4" "q5"
    vektör için collapse = python join: >
      paste(c("ali","veli"), collapse=",")
      [1] "ali,veli"
    collapse: tek parçaya collapse eder
    sep: concat edilen stringler nasıl ayrılmalı. 
    ex01: >
      paste0('converted ', 'here')
      [1] 'converted here'
  string/regex:
    string.regex/ref: [info, string.regex/ref]
    string.regex/kd: [info, string.regex/kd]
    string.regex/stringr: [info, string.regex/stringr]
    string.regex/lookaround: [info, string.regex/lookaround]
    string.regex/escapes backslashes: [info, string.regex/escapes backslashes]
    string.regex/character classes: [info, string.regex/character classes]
    string.regex/examples: [info, string.regex/examples]
  string.regex/ref: 
    ttl: https://www.regex101.com/ 
    dsc: debug regex
  string.regex/kd: >
    grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE)
    grepl(pattern, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)
      str_detect
    sub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)
    gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)
    regexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)
    gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)
    regexec(pattern, text, ignore.case = FALSE, fixed = FALSE, useBytes = FALSE)
  string.regex/stringr:
    string.regex.stringr/nrm: str_replace(string, pattern, replacement) # "string" %s/pattern/repl/
    string.regex.stringr/ex01: [info, string.regex.stringr/ex01]
    string.regex.stringr/ex02: [info, string.regex.stringr/ex02]
    string.regex.stringr/multiple patterns: [info, string.regex.stringr/multiple patterns]
    string.regex.stringr/str_match: [info, string.regex.stringr/str_match]
    string.regex.stringr/str_locate: [info, string.regex.stringr/str_locate]
    string.regex.stringr/str_extract: [info, string.regex.stringr/str_extract]
    string.regex.stringr/str_trunc: [info, string.regex.stringr/str_trunc]
  string.regex.stringr/ex01: >
    str_replace(fruits, "[aeiou]", "-")
  string.regex.stringr/ex02: >
    str_replace_all(fruits, "[aeiou]", "-")
    str_replace_all("\t(\\w+)", "\n  - \\1") 
  string.regex.stringr/multiple patterns: >
    fruits <- c("one apple", "two pears", "three bananas")
    # If you want to apply multiple patterns and replacements to the same
    # string, pass a named version to pattern.
    str_replace_all(str_c(fruits, collapse = "---"),
    c("one" = 1, "two" = 2, "three" = 3)) 
    # [1] "1 apple---2 pears---3 bananas"
  string.regex.stringr/str_match: >
    strings = c(" 219 733 8965", "329-293-8753 ", "banana")
    pattern <- "([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"
    str_extract(strings, pattern)
    m = str_match(strings, pattern)
           [,1]      [,2] [,3]  [,4]
      [1,] "219 733 8965" "219" "733" "8965"
      [2,] "329-293-8753" "329" "293" "8753"
      [3,] NA      NA NA  NA
    m[1,1] # match 1 group 1
    m[1,2] # match 1 group 2
  string.regex.stringr/str_locate: >
    str_locate("aaa12xxx", "[0-9]+")
    #      start end
    # [1,]     4   5
  string.regex.stringr/str_extract: >
    str_extract("aaa12xxx", "[0-9]+")
      # [1] "12"
  string.regex.stringr/str_trunc: >
    str_trunc(string, width, side = c("right", "left", "center"), ellipsis = "...") # truncate
    str_trunc(x, 20, "right"),
    str_trunc(x, 20, "left"),
    str_trunc(x, 20, "center")
  string.regex/lookaround:
    lookbehind: >
      (?<=) positive
      (?<!) positive
    lookahead: >
      (?=)  positive
      (?!)  negative
  string.regex/escapes backslashes:
    dsc: backslashes need to be doubled for regex
    newline:- single: >
      "\n"
      cat("this\nis new")
      # this
      # is new
  string.regex/character classes: >
    [:alnum:]
      [:alpha:] [:digit]
    [:blank:]
  string.regex/examples:
    trim whitespace: >
      # returns string w/o leading whitespace
      trim.leading <- function (x)  sub("^\\s+", "", x)
        # returns string w/o trailing whitespace
      trim.trailing <- function (x) sub("\\s+$", "", x)
        # returns string w/o leading or trailing whitespace
      trim <- function (x) gsub("^\\s+|\\s+$", "", x)
      To use one of these functions on myDummy$country:
      myDummy$country <- trim(myDummy$country)
  string/character functions:
    string/nchar(x): [info, string/nchar(x)]
    string/substr(x, start, stop): [info, string/substr(x, start, stop)]
    string/grep(pattern, x, ignore.case=FALSE, fixed=FALSE): [info, string/grep(pattern, x, ignore.case=FALSE, fixed=FALSE)]
    string/sub(pattern, replacement, x, ignore.case=FALSE, fixed=FALSE): [info, string/sub(pattern, replacement, x, ignore.case=FALSE, fixed=FALSE)]
    string/strsplit(x, split): [info, string/strsplit(x, split)]
    string/paste(..., sep=""): [info, string/paste(..., sep="")]
    string/case conversions: [info, string/case conversions]
  string/nchar(x): >
    number of char in x
  string/substr(x, start, stop): >
    substr(x, 2, 4)
    substr(x, 2, 4) <- "222"
  string/grep(pattern, x, ignore.case=FALSE, fixed=FALSE): >
    fixed=FALSE   regex
    returns matching indices
  string/sub(pattern, replacement, x, ignore.case=FALSE, fixed=FALSE): >
    sub("\\s", ".", "Hello there")
    > Hello.there
  string/strsplit(x, split): >
    strsplit("abc", "")
  string/paste(..., sep=""): >
    concatenate strings
    paste("x", 1:3, sep="m")
    > c("xM1", "xm2", "xm3")
    paste( 1:3, collapse = "; " )
    > [1] "1; 2; 3"
  string/case conversions:
    toUnderscore(x): >
      convert camel case to underscore separated lower case
    toupper(x): _
    tolower(x): _
    tocamel(x): >
      library("rapportools")
      tocamel("foo.bar")
      ## [1] "fooBar"
      tocamel("foo.bar", upper = TRUE)
      ## [1] "FooBar"
      tocamel(c("foobar", "foo.bar", "camel_case", "a.b.c.d"))
      ## [1] "foobar"    "fooBar"    "camelCase" "aBCD"
    unicode:- stri_trans_tolower: >
      stri_trans_totitle( locale = "tr_TR" )
    str_to_upper(string, locale = "en"): _
    str_to_lower(string, locale = "en"): _
    str_to_title(string, locale = "en"): _
    str_to_sentence(string, locale = "en"): _
  string/stringr:
    string.stringr/ref: [info, string.stringr/ref]
    string.stringr/str_trim: [info, string.stringr/str_trim]
    string.stringr/str_split: [info, string.stringr/str_split]
    string.stringr/basic: [info, string.stringr/basic]
    string.stringr/pattern matching: [info, string.stringr/pattern matching]
  string.stringr/ref:
    ~/projects/study/r/study_stringr.Rmd
  string.stringr/str_trim: >
    str_trim(string, side = c("both", "left", "right"))
    x %>% 
      str_trim(side = "both")
  string.stringr/str_split:
    ftr: returns list
    string.stringr/str_split with dplyr:- take last element: [info, string.stringr/str_split with dplyr:- take last element]
    string.stringr/use unlist to convert to vector: [info, string.stringr/use unlist to convert to vector]
    string.stringr/str_split then convert to dataframe column  id=sr_0003: [info, string.stringr/str_split then convert to dataframe column  id=sr_0003]
    string.stringr/ex01: [info, string.stringr/ex01]
  string.stringr/str_split with dplyr:- take last element: >
    df = data_frame( a = c("ali,veli", "can,cin" ) )
    d6 = df %>%
      mutate( b = str_split(a, ",") ) %>%
      unnest(b) %>%
      group_by(a) %>%
      filter(row_number()==n())
  string.stringr/use unlist to convert to vector: >
    t %>%
    str_split("\\n") %>%
    unlist
  string.stringr/str_split then convert to dataframe column  id=sr_0003: >
    d4 = ft %>%
      mutate( bn = str_split(sinif_tip_formasiya_adi, "\\(") ) %>%
      unnest(bn) %>%
      group_by( fte_id ) %>%
      mutate( info = row_number() ) %>%
      spread( info, bn ) %>%
      rename( dom_subdom = `1`, bitki_adlari = `2`, other = `3` )
  string.stringr/ex01: >
    str_trim( unlist( str_split(goog,',') ) )
      [1] "GOOG"  "GOOGL"
  string.stringr/basic:
    string.stringr/str_c:- concetenate: [info, string.stringr/str_c:- concetenate]
    string.stringr/str_length: [info, string.stringr/str_length]
    string.stringr/str_sub: [info, string.stringr/str_sub]
    string.stringr/str_str<-: [info, string.stringr/str_str<-]
    string.stringr/str_dup: [info, string.stringr/str_dup]
    string.stringr/str_trim: _
    string.stringr/str_pad: [info, string.stringr/str_pad]
  string.stringr/str_c:- concetenate:
    paste0 like
  string.stringr/str_length: >
    nchar like
    preserves NA
  string.stringr/str_sub:
    dsc: >
      substr like
      negative positions
        end: -1
      zero length input
    ex: >
      hw <- "Hadley Wickham"
      str_sub(hw, 1, 6)
      str_sub(hw, end = 6)
      str_sub(hw, 8, 14)
      str_sub(hw, 8)
      str_sub(hw, c(1, 8), c(6, 14))
      # Negative indices
      str_sub(hw, -1)
      str_sub(hw, -7)
      str_sub(hw, end = -7)
      # Alternatively, you can pass in a two colum matrix, as in the
      # output from str_locate_all
      pos <- str_locate_all(hw, "[aeio]")[[1]]
      str_sub(hw, pos)
      str_sub(hw, pos[, 1], pos[, 2])
      # Vectorisation
      str_sub(hw, seq_len(str_length(hw)))
      str_sub(hw, end = seq_len(str_length(hw)))
      # Replacement form
      x <- "BBCDEF"
      str_sub(x, 1, 1) <- "A"; x
      str_sub(x, -1, -1) <- "K"; x
      str_sub(x, -2, -2) <- "GHIJ"; x
      str_sub(x, 2, -2) <- ""; x 
  string.stringr/str_str<-:
    substr<-
  string.stringr/str_dup:
    to duplicate chars
  string.stringr/str_pad:
    pad extra whitespace
  string.stringr/pattern matching:
    string.stringr/detect: [info, string.stringr/detect]
    string.stringr/locate: [info, string.stringr/locate]
    string.stringr/extract: [info, string.stringr/extract]
    string.stringr/match: [info, string.stringr/match]
    string.stringr/replace: [info, string.stringr/replace]
    string.stringr/split: [info, string.stringr/split]
  string.stringr/detect: >
    str_detect
      grepl like
  string.stringr/locate: >
    str_locate
    str_locate_all
    based on: regexpr
  string.stringr/extract: >
    str_extract
    str_extract_all
  string.stringr/match:
    str_match:
      capture groups by ()
    return:- matrix:
      one column for each group
    str_match_all: _
  string.stringr/replace: >
    str_replace
    str_replace_all
    based: sub
    backreferences
      \1 \2
  string.stringr/split:
    str_split_fixed
  string/unicode:
    string.unicode/detect encoding: [info, string.unicode/detect encoding]
    string.unicode/totitle case: [info, string.unicode/totitle case]
    string.unicode/transliterate: [info, string.unicode/transliterate]
  string.unicode/detect encoding: >
    s = readLines(paste0(dir, "siparisler.csv"), n = 100) %>% paste(collapse = "\\n")
    if (stri_enc_isutf8(s)) 
  string.unicode/totitle case: >
    label %>%
      str_replace_all( "_", " " ) %>%
      stri_trans_totitle( locale = "tr_TR" )
  string.unicode/transliterate:
    iconv: >
      x = "Addyişm__NİO_Yasamal.PDF"
      iconv(x, "utf-8", "ASCII//TRANSLIT")
    stringi: >
      label %>%
        stri_trans_totitle( locale = "tr_TR" )
    regex: >
      transliterate_tr_to_ascii = function( lines ) {
        lines %>%
          str_replace_all(c("ü"="u", "ö"="o", "ı"="i", "Ü"="U", "Ö"="O", "İ"="I", "ş"="s", "ğ"="g", "ç"="c", "Ş"="S", "Ğ"="G", "Ç"="C", "ə"="e", "Ə"="E"))
      }
  string/examples:
    append new lines: >
      r = character()
      r = c(r, sprintf("filings that don't have xbrl: %s", length(missing_xbrl)))
  tidyr/tutorial:
    https://rpubs.com/bradleyboehmke/data_wrangling
  tidyr/extract_numeric:
    mutate(valuation = extract_numeric(`Valuation ($B)`))
  tidyr/spread: >
    takes key-value columns, spreads into multiple columns
    logn to wider
  tidyr/unite:
    dsc: >
      reverse of separate
      unite multiple columns into single
    ex01: >
      unite(df, "New_Column", col1:coln)
    ex02:
      kd: unite(df, "New_Column", col1:coln, sep = ";", remove = FALSE)
      remove: eski kolonları silme
      sep: birleştirme separator
  tidyr/gather:
    dsc: >
      takes multiple columns, gathers them into key-value pairs
      wide to longer
    ex:
      data: >
        trt wT1 hT1 wT2 hT2
        ....
      output: >
        trt key value
        ..  wT1 ..
        ..  wT2 ..
      api: >
        gather( data, key, value, ..)
          data: df
          key: column for new variable
          value: column for values
        gather( data, key, value, wT1:hT2)
  tidyr/reshape:
    dsc: reverse gather
    api:
      data: >
        trt key value
        ..  wT1 ..
        ..  wT2 ..
      output: >
        trt wT1 hT1 wT2 hT2
        ....
      spread(data, key, value, ..):
        dsc: reshaping long format to wide format
        params:
          data: df
          key: column to convert
          value: new column
        error:- duplicate identifiers for rows: >
          bir identifier eklemelisin
          mutate( row = row_number() ) 
      gather( data, key, value): _
  tidyr/separate:
    dsc: split single column into multiple
    ex:
      data: >
        yr  qtr rev
        ..  q1  10
        ..  q2  20
      output: >
        yr  int id  rev
        ..  q   1   10
        ..  q   2   20
      api:
        separate( data, col, into, sep):
          data: df
          col: current var
          into: new variables
          sep: separator
  httr/POST: >
    b2 <- "http://httpbin.org/post"
    POST(b2, body = "A simple text string")
  httr/Debugging http requests: >
    response <- httr::POST("http://localhost:8888/rest/table01", 
                          body = list(id = 601, title = "t601"),
                          encode = "json", verbose()
                          )
    add_headers(
      Authorization = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJyb2xlIjoid2VidXNlciJ9.uSsS2cukBlM6QXe4Y0H90fsdkJSGcle9b7p_kMV1Ymk", 
      Content-Type = "text/csv"
    body = upload_file("~/projects/study/db/ex/study_postgrest/e03/table01.csv"),
  plumber/ref: >
    ~/projects/study/r/study_plumber_restful_apis.Rmd 
    ~/projects/study/db/study_postgrest.Rmd <url:file:///~/gdrive/mynotes/content/code/cdb.md#r=g10633>
    ~/projects/study/js/study_expressjs_server.Rmd <url:file:///~/gdrive/mynotes/content/code/cjs/cjs.md#r=g10634>
  plumber/run plumber: >
    pr <- plumber::plumb("e01.R")
    pr$run(port=4500)
  plumber/ex01:- basic service:
    rest service definition: >
      #' @get /echo
      function(msg){ list(msg = paste0('The message is:-', msg)) }
    client curl:
      curl http://localhost:4500/echo
  plumber/ex02:- service with argument:
    rest service: >
      #' @post /add1
      function(num=0){
    curl client: >
      curl -X POST -H "Content-Type: application/json" -d '{"num":"3"}' http://localhost:4500/add1
      # {"y":[4]}
    cyclejs client: >
      const requests$ = xs.from( [ {
        url: 'http://localhost:4500/add2',
        send: '{"num":"3"}',
  plumber/ex04:- file upload service:
    rest service: >
      #' @post /echo2
      function(req){
        formContents = Rook::Multipart$parse(req)
        somefile <- readLines(con = formContents$upload$tempfile)
        print(formContents$upload$tempfile)
        list(formContents=formContents)
    curl client: >
      curl -v -F foo=bar -F upload=@e01.R http://localhost:7814/echo2
    superagent client: >
      superagent.post( 'http://localhost:4500/echo2' )
        .set('Content-Type', 'multipart/form-data')
        .attach('upload', '~/projects/study/r/ex/study_plumber_restful_apis/e01.R')
    cyclejs client: >
      url: 'http://localhost:4755/echo2',
      method: 'POST',
      attach: [
        {
          name: 'upload',
          path: '~/projects/study/r/ex/study_plumber_restful_apis/e01.R',
          filename: 'e01.R'
  bookmark/presentation library: 
    xaringan
  bookmark/igraph tutorial:
    http://kateto.net/network-visualization
  bookmark/datapasta: >
    RStudio Addins for Data Copy-Pasta
    RStudio addins to make copy-pasting vectors and tables into source painless.
