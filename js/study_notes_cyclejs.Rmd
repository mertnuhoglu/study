---
title: "Study Notes for CycleJs"
date: 2018-02-26T22:04:09+03:00 
draft: false
description: ""
tags:
categories: cyclejs, javascript
type: post
url:
author: "Mert Nuhoglu"
output:
  html_document:
    css: styles.css
blog: mertnuhoglu.com
resource_files:
- ex/cyclejs_ex17.js
- ex/cyclejs_ex16.js
- ex/cyclejs_ex15.js
- ex/cyclejs_ex14.js
- ex/cyclejs_ex13.js
- ex/cyclejs_ex12.js
- ex/cyclejs_ex11.js
- ex/cyclejs_ex10.js
- ex/cyclejs_ex09.js
- ex/cyclejs_ex08.js
- ex/cyclejs_ex07.js
- ex/cyclejs_ex06.js
- ex/cyclejs_ex05.js
- ex/cyclejs_ex04.js
- ex/cyclejs_ex03.js
- ex/cyclejs_ex02.js
- ex/cyclejs_ex17.html
- ex/cyclejs_ex16.html
- ex/cyclejs_ex15.html
- ex/cyclejs_ex14.html
- ex/cyclejs_ex13.html
- ex/cyclejs_ex12.html
- ex/cyclejs_ex11.html
- ex/cyclejs_ex10.html
- ex/cyclejs_ex09.html
- ex/cyclejs_ex08.html
- ex/cyclejs_ex07.html
- ex/cyclejs_ex06.html
- ex/cyclejs_ex05.html
- ex/cyclejs_ex04.html
- ex/cyclejs_ex03.html
- ex/cyclejs_ex02.html
- ex/cyclejs_ex01.html
path: ~/projects/study/js/study_notes_cyclejs.Rmd
state: wip
---

<style>
  .main-container {
    max-width: 1600px !important;
  }
</style>

``` {r set-options}
options(width = 150)
options(max.print = 30)
``` 

This blog post is simply my work through notes while studying great video course of [CycleJs Fundamentals](https://egghead.io/courses/cycle-js-fundamentals) given by [Andre Staltz](https://twitter.com/andrestaltz) freely on [egghead](https://egghead.io/).

I really love Andre's style of teaching. He explains hard topics in a very easy to understand way. 

# Andre Staltz' CycleJs Fundamentals

## v01

<iframe src="ex/cyclejs_ex01.html" width="200" height="30"></iframe>

Edit `ex/cyclejs_ex01.html`

``` html
...
<div id="app"></div>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.6/Rx.min.js"></script>
<script>
  Rx.Observable.timer(0, 1000)
    .map(i => `Seconds ${i}`)
    .subscribe(text => {
      const container = document.querySelector('#app');
      container.textContent = text;
    })
</script>
``` 

This code consists of two parts: 

1. Logic

        Rx.Observable.timer(0, 1000)
          .map(i => `Seconds ${i}`)

2. Effects

          .subscribe(text => {
            const container = document.querySelector('#app');
            container.textContent = text;
          })

We want to separate these two parts.

Effects are everything that changes external world. Here we change the web page or DOM. console.log and http requests are all effects. These codes are put into `subscribe()` function.

Logic part doesn't change external world.

Effects part is imperative. Logic part is functional. We need to separate these two parts. Effects part needs to be handled by the framework. Application should consist only of the logic part. 

## v02

Now, let's encapsulate logic and effects parts into two separate functions.

Edit `ex/cyclejs_ex02.js`

``` js
function main() {
  return Rx.Observable.timer(0, 1000)
    .map(i => `Seconds ${i}`);
}

function DOMEffect(text$) {
  text$.subscribe(text => {
    const container = document.querySelector('#app');
    container.textContent = text;
  });
}

DOMEffect(main());
``` 

<iframe src="ex/cyclejs_ex02.html" width="200" height="30"></iframe>

We can use the rx observable in other effects too. For example:

Edit `ex/cyclejs_ex03.js`

``` js
...
function consoleLogEffect(msg$) {
  msg$.subscribe(msg => console.log(msg));
}

const sink = main();
consoleLogEffect(sink);
DOMEffect(sink);
``` 

<iframe src="ex/cyclejs_ex03.html" width="200" height="30"></iframe>

## v03

We have two types effects: consoleLogEffect and DOMEffect. But they both show the same stream from main(). 

Now, we want to show two different streams.

<iframe src="ex/cyclejs_ex04.html" width="200" height="30"></iframe>

Edit `ex/cyclejs_ex04.js`

``` js
function main() {
  return {
    DOM: Rx.Observable.timer(0, 1000)
      .map(i => `Seconds ${i}`),
    Log: Rx.Observable.timer(0, 2000)
      .map(i => 2*i),
  };
}

...
const sink = main();
consoleLogEffect(sink.Log);
DOMEffect(sink.DOM);
``` 

Logic is put into main() function. Effects are put into their own respective functions.

## v04

The last part joins logic part and effects part. We will encapsulate it into `run()` function.

``` js
function run(main) {
  const sinks = main();
  consoleLogEffect(sinks.Log);
  DOMEffect(sinks.DOM);
}
run(main);
``` 

But now the effects are hard-coded. Let's parameterize it too:

Edit `ex/cyclejs_ex05.js`

``` js
function run(main, effects) {
  const sinks = main();
  Object.keys(effects).forEach(key => {
    effects[key](sinks[key])
  })
}

const effects = {
  DOM: DOMEffect,
  Log: consoleLogEffect,
}
run(main, effects);
``` 

<iframe src="ex/cyclejs_ex05.html" width="200" height="30"></iframe>

Now, rename `effects` function as `drivers`. The reason for this renaming is that drivers are interfaces between software and hardware. Our drivers are interfaces between program (logic part) and effects.

Edit `ex/cyclejs_ex06.js`

``` js
const drivers = {
  DOM: DOMDriver,
  Log: consoleLogDriver,
}
``` 

<iframe src="ex/cyclejs_ex06.html" width="200" height="30"></iframe>

Data flow between modules occurs as follows:

		B: Browser
		DD: DOMDriver
		m: main
		
		[B] -> evt -> [DD] -> click$ -> [m] -> text$ -> [DD] -> doc.innerHTML -> [B]
                            |                |
                          DOMSource        main.sinks.DOM

    click$ = DOMSource
		text$ = main.sinks.DOM

Note that, there are two side effects:

		evt: input side effect
		doc.innerHTML: output side effect

Note that, the side effects are handled in `subscribe` and `Rx.Observable.fromEvent`. Although these side effects are input/output of `DOMDriver`, they are not argument/return expressions. 

		evt -> Rx.Observable.fromEvent(...)
		doc.innerHTML -> text$.subscribe(...)

Also note that, input and output side effects are at the beginning and end of the application's interface to external world.

``` js
function DOMDriver(text$) {
  text$.subscribe(text => {
    const container = document.querySelector('#app');
    container.textContent = text;
  });
  const DOMSource = Rx.Observable.fromEvent(document, 'click');
  return DOMSource;
}
``` 

## v05

All the effects above are write effects. We don't have any input from external world until now.

Our program (main) should be able to get input from external world.

Inputs from external world are called as read (input) effects and as sources. Outputs to external world are called as write (output) effects and as sinks. 

Source/sink or input/output are named from the perspective of `main()` function. The logic part of the application is in `main()` function. There are some external inputs or sources to this program. They are called as input effects. And there are some external outputs or sinks from this program. They are called as write effects.

``` js
function DOMDriver(text$) {
  ...
  const DOMSource = Rx.Observable.fromEvent(document, 'click');
  return DOMSource;
}

function run(main, drivers) {
  const sinks = main(DOMSource);
  const DOMSource = drivers.DOM(sinks.DOM);
  //Object.keys(drivers).forEach(key => {
    //drivers[key](sinks[key])
  //})
}
``` 

But there is a cyclic dependency problem here:

    const sinks = main(DOMSource);
    const DOMSource = drivers.DOM(sinks.DOM);

This is similar to the following problem:

    a = f(b)
    b = g(a)

To solve this cyclic dependency, we need to introduce bProxy as the first input argument:

    bProxy = ...
    a = f(bProxy)
    b = g(a)
    bProxy.imitate(b)

So, we pass an empty stream as the initial input argument of `main()` 

    const proxyDOMSource = new Rx.Subject();
    const sinks = main(proxyDOMSource);
    const DOMSource = drivers.DOM(sinks.DOM);
    DOMSource.subscribe(click => proxyDOMSource.next(click));

Now, let's use this input source stream in our example. Instead of using `Rx.Observable.timer` stream once, let's use click stream to restart `timer`.

Edit `ex/cyclejs_ex07.js`

``` js
function main() {
  return {
    DOM: Rx.Observable.timer(0, 1000)
      .map(i => `Seconds ${i}`),
    Log: Rx.Observable.timer(0, 2000)
      .map(i => 2*i),
  };
}

--->>>

function main(DOMSource) {
  const click$ = DOMSource;
  return {
    DOM: click$
      .startWith(null)
      .switchMap(() =>
        Rx.Observable.timer(0, 1000)
          .map(i => `Seconds ${i}`)
      ),
    Log: Rx.Observable.timer(0, 2000).map(i => 2*i),
  };
}
``` 

Now, clicking anywhere in the web page, restarts the `timer` count from zero.

<iframe src="ex/cyclejs_ex07.html" width="200" height="30"></iframe>

## v06

Now, parameterize input source arguments to main() function. There can be different types of drivers.

Edit `ex/cyclejs_ex08.js`

``` js
function main(DOMSource) {

--->>>

function main(sources) {
  const click$ = sources.DOM;
``` 

``` js
function run(main, drivers) {
  const proxyDOMSource = new Rx.Subject();
  const sinks = main(proxyDOMSource);

--->>>

function run(main, drivers) {
  const proxySources = {}
  Object.keys(drivers).forEach(key => {
    proxySources[key] = new Rx.Subject();
  })
  const sinks = main(proxySources);
  Object.keys(drivers).forEach(key => {
    const source = drivers[key](sinks[key]);
    source.subscribe(x => proxySources[key].next(x));
  })
}
``` 

This `run` function is totally generic. It doesn't contain any application specific code. Therefore, we can move it to an external framework. This is what `cycle-core` library does.

``` js
Cycle.run(main, drivers);
``` 

`Cycle.run` function is defined in:

    <script src="https://rawgit.com/cyclejs/cycle-core/v6.0.0/dist/cycle.js"></script>

<iframe src="ex/cyclejs_ex08.html" width="200" height="30"></iframe>

## v07 Improving DOM Driver

Now, let's return HTML element stream instead of text stream inside the DOM driver.

Edit `ex/cyclejs_ex09.js`

``` js
      .flatMapLatest(() =>
        Rx.Observable.timer(0, 1000)
          .map(i => `Seconds ${i}`)
      ),

      --->>>

      .flatMapLatest(() =>
        Rx.Observable.timer(0, 1000)
          .map(i => {
              return {
                tagName: 'H1',
                children: [
                  `Seconds ${i}`
                ]
              }
            }
          )
      ),
``` 

``` js
  text$.subscribe(text => {
    const container = document.querySelector('#app');
    container.textContent = text;
  });

  --->>>

  function createElement(obj) {
    const element = document.createElement(obj.tagName);
    element.innerHTML = obj.children[0];
    return element;
  }
  obj$.subscribe(obj => {
    const container = document.querySelector('#app');
    container.innerHTML = '';
    const element = createElement(obj);
    container.appendChild(element);
  });
``` 

<iframe src="ex/cyclejs_ex09.html" width="200" height="30"></iframe>

But this solution contains hard-coded code inside `createElement`. We might have different types of elements in the stream.

Let's make `createElement` more generic:

``` js
          .map(i => {
              return {
                tagName: 'H1',
                children: [
                  `Seconds ${i}`
                ]
              }
            }

          --->>>

          .map(i => {
              return {
                tagName: 'H1',
                children: [
                  {
                    tagName: 'SPAN',
                    children: [
                      `Seconds ${i}`
                    ]
                  }
                ]
              }
            }
``` 

``` js
  function createElement(obj) {
    const element = document.createElement(obj.tagName);
    element.innerHTML = obj.children[0];
    return element;
  }

  --->>>

  function createElement(obj) {
    const element = document.createElement(obj.tagName);
    obj.children
      .filter(c => typeof c === 'object')
      .map(createElement)
      .forEach(c => element.appendChild(c));
    obj.children
      .filter(c => typeof c === 'string')
      .forEach(c => element.innerHTML += c);
    return element;
  }
``` 

<iframe src="ex/cyclejs_ex10.html" width="200" height="30"></iframe>

## v08: Different Types of Input Events

Currently, we have only click type input events. But there are other types of input events too, such as `mouseover`.

Edit `ex/cyclejs_ex11.js`

``` js
  const DOMSource = Rx.Observable.fromEvent(document, 'click');

  --->>>

  const DOMSource = {
    selectEvents: function(tagName, eventType) {
      return Rx.Observable.fromEvent(document, eventType)
        .filter(ev => ev.target.tagName === tagName.toUpperCase());
    }
  }
``` 

``` js
  const click$ = sources.DOM;

  --->>>

  const mouseover$ = sources.DOM.selectEvents('span', 'mouseover');
``` 

<iframe src="ex/cyclejs_ex11.html" width="200" height="30"></iframe>

## v09

Our view code can be automated a little further:

Edit `ex/cyclejs_ex12.js`

``` js
              return {
                tagName: 'H1',
                children: [
                  {
                    tagName: 'SPAN',
                    children: [
                      `Seconds ${i}`
                    ]
                  }
                ]
              }

--->>> 

function h(tagName, children) {
  return {
    tagName: tagName,
    children: children,
  }
}

              return {
                h('H1', [
                  h('SPAN', [
                    `Seconds ${i}`
                  ])
                ])
``` 

<iframe src="ex/cyclejs_ex12.html" width="200" height="30"></iframe>

Now, we can further simplify by defining a new helper function for each `tagName`:

``` js
function h1(children) {
  return {
    tagName: 'H1',
    children: children,
  }
}

function span(children) {
  return {
    tagName: 'SPAN',
    children: children,
  }
}

                ...
                h1([
                  span([
                    `Seconds ${i}`
                  ])
                ])
``` 

Now, we can use js functions instead of a markup language such as HTML or templating language such as PUG or Mustache.

## v10

Can we move DOMDriver into an external framework? Yes, only application specific code inside DOMDriver is HTML element id `#app`.

Edit `ex/cyclejs_ex13.js`

``` js
function DOMDriver(obj$) {
  function createElement(obj) {
    const element = document.createElement(obj.tagName);
    obj.children
      .filter(c => typeof c === 'object')
      .map(createElement)
      .forEach(c => element.appendChild(c));
    obj.children
      .filter(c => typeof c === 'string')
      .forEach(c => element.innerHTML += c);
    return element;
  }
  obj$.subscribe(obj => {
    const container = document.querySelector('#app');
    container.innerHTML = '';
    const element = createElement(obj);
    container.appendChild(element);
  });
  const DOMSource = {
    selectEvents: function(tagName, eventType) {
      return Rx.Observable.fromEvent(document, eventType)
        .filter(ev => ev.target.tagName === tagName.toUpperCase());
    }
  }
  return DOMSource;
}

--->>>


function makeDOMDriver(mountSelector) {
  return function DOMDriver(obj$) { ... }
   
----

const drivers = {
  DOM: DOMDriver,

--->>>

const drivers = {
  DOM: makeDOMDriver('#app'),

``` 

<iframe src="ex/cyclejs_ex13.html" width="200" height="30"></iframe>

One critical issue performance-wise is the following line because we are recreating the complete inner DOM tree from scratch after every event:

    container.innerHTML = '';

Another issue is that we don't yet support CSS selectors except `tagName`. We should support CSS selectors such as `.class`.

To solve these issues, we can use the actual cyclejs library instead of helper functions and driver functions.

``` {bash}
cat ex/cyclejs_ex14.js
``` 

<iframe src="ex/cyclejs_ex14.html" width="200" height="30"></iframe>

Edit `ex/cyclejs_ex14.js`

``` js
const {h, h1, span, makeDOMDriver} = CycleDOM;
...
  const mouseover$ = sources.DOM.select('span').events('mouseover');
``` 

CycleDOM actually uses virtual DOM objects. This improves the performance of DOM updates a lot.

You can also specify attributes of HTML elements:

            h1( {style: {background: 'yellow'}}, [

## v11 Hello World App

Edit `ex/cyclejs_ex15.js`

``` {bash}
cat ex/cyclejs_ex15.js
``` 

<iframe src="ex/cyclejs_ex15.html" width="200" height="150"></iframe>

## v12: Decrement Increment: State

Edit `ex/cyclejs_ex16.js`

``` {bash}
cat ex/cyclejs_ex16.js
``` 

<iframe src="ex/cyclejs_ex16.html" width="200" height="150"></iframe>

## v13: HTTP Driver

Edit `ex/cyclejs_ex17.js`

``` {bash}
cat ex/cyclejs_ex17.js
``` 

<iframe src="ex/cyclejs_ex17.html" width="200" height="250"></iframe>

## v14: BMI Calculator

## v18: Onionify

``` bash
mkdir -p ex/study_notes_cyclejs/ex18 && cd $_ && npm init -y && npm i parcel-bundler --save-dev && npm i xstream @cycle/run @cycle/dom @cycle/http
``` 

`ex/study_notes_cyclejs/ex18/package.json`

    "start": "parcel index.html",
    "build": "parcel build index.html --public-url ./",

Edit `ex/study_notes_cyclejs/ex18/index.js`

    npm start
 
    http://localhost:1234


# Reference CycleJs Examples

## ref01: Simple CycleJs with import + parceljs

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/ref_ex/ref01/index.js`

``` js
import {run} from '@cycle/run';
import {div, label, input, hr, h1, makeDOMDriver} from '@cycle/dom';

function main(sources) {
  const vdom$ = sources.DOM
    .select('.myinput').events('input')
    .map(ev => ev.target.value)
    .startWith('')
    .map(name =>
      div([
        label('Name:'),
        input('.myinput', {attrs: {type: 'text'}}),
        hr(),
        h1(`Hello ${name}`)
      ])
    );
  return {
    DOM: vdom$,
  };
}

run(main, {
  DOM: makeDOMDriver('#app')
});

``` 

Edit `~/projects/study/js/ex/study_notes_cyclejs/package.json`

``` js
...
  "scripts": {
    "ref01": "parcel ref_ex/ref01/index.html",
``` 

## ref02: Simple CycleJs xs.of instead of sources.DOM

Edit `~/projects/study/js/ex/study_notes_cyclejs/ref_ex/ref02/index.js`

``` js
import xs from 'xstream';
import {run} from '@cycle/run';
import {div, makeDOMDriver} from '@cycle/dom';

function main(sources) {
  const vdom$ = xs.of(
    div("planet earth")
  )
  return {
    DOM: vdom$,
  };
}

run(main, {
  DOM: makeDOMDriver('#app')
});
``` 

## ref03: Simple Onion

Based on ~/codes/js/cycle-onionify/examples/basic/src/main.js

Edit `~/projects/study/js/ex/study_notes_cyclejs/ref_ex/ref03/index.js`

``` js
...
  const state$ = sources.onion.state$
    .debug( x => {
      global.x = x
      console.log(x)
    } )
...
  const reducer$ = xs.merge(initReducer$, updateReducer$)
    .debug(console.log)
``` 

Executing the web page prints on Console:

``` js
ƒ initReducer() {
  return { count: 0 };
}
{count: 0}
``` 

## ref04: HTTP Request

Based on `/Users/mertnuhoglu/codes/js/cyclejs/examples/basic/http-random-user`

Edit `~/projects/study/js/ex/study_notes_cyclejs/ref_ex/ref04/index.js`

## ref05: Multiple HTTP Requests

Based on `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/index_04.js`

Edit `~/projects/study/js/ex/study_notes_cyclejs/ref_ex/ref05/index.js`

## ref06: Complex App: Multiple Components + Onion + Multiple HTTP Requests

Based on ~/projects/study/js/vrp/ex/cyclejs_vrp/ex15/src07/

Edit `~/projects/study/js/ex/study_notes_cyclejs/ref_ex/ref06/index.js`

## ref07: Node Apps

Based on `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex01.js`

		refblc: p16: onion with one subcomponent and lens <url:file:///~/projects/study/js/study_notes_cyclejs.Rmd#r=g_10221>

## ref08: Full CycleJs App:

		refblc: cyclejs ex15_10_05 <url:file:///~/gdrive/mynotes/content/code/cjs/cjs.md#r=g_10585>

# Article: Handling lists in Cyclejs

https://github.com/cyclejs/cyclejs/issues/312

## How to create Dynamic List Components

A component that consists of a dynamic number of child components

List of child components is dynamic:

- create/add child
- remove child
- change order of children
- change of child state may cause change of list component state

Communication: Components exchange data.

- grandparent <-> parent <-> child(ren)

Ex: TodoMVC with onionify:

https://github.com/cyclejs/todomvc-cycle/tree/onionify

# Problems

``` bash
mkdir -p ex/study_notes_cyclejs && cd $_ && npm init -y && pnpm i parcel-bundler --save-dev && npm i xstream @cycle/run @cycle/dom @cycle/http cycle-onionify cycle-storageify @cycle/storage typestyle bootstrap jquery jquery-ui-dist popper.js handsontable
node ex/study_functional_programming_in_javascript_learnrx/ex01.js
``` 

## Common For Some Subprojects:

Start database server and postgrest:

``` bash
export PROJECT_DIR=$HOME/projects/itr
export VRP_PSK_DIR=$PROJECT_DIR/vrp_psk01
cd $VRP_PSK_DIR
docker-compose up 
``` 

## p01: Multiple HTML Elements As vdom 

``` bash
mkdir -p ex/study_notes_cyclejs/p01
``` 

Opt01: xs.of + one div vdom 

Edit `ex/study_notes_cyclejs/src/problems/p01/index_01.js`

``` js
...
  const vdom$ = xs.of(
    div("div01"),
  )
``` 

``` js
  console.log(Object.getOwnPropertyNames(vdom$))
  console.log(Reflect.ownKeys(vdom$))
// Array(7)0: "_prod"1: "_ils"2: "_stopID"3: "_dl"4: "_d"5: "_target"6: "_err"length: 7__proto__: Array(0)
``` 

<div class="app"><div>div01</div></div>

Opt02: xs.of + multiple div vdom

Edit `ex/study_notes_cyclejs/src/problems/p01/index_02.js`

``` js
...
  const vdom$ = xs.of(
    div("div01"),
    div("div02"),
  )
``` 

<div class="app"><div>div02</div></div>

Note that, virtual dom should consist only of a single outer element.

Opt03: xs.of + multiple div inside a single div

Edit `ex/study_notes_cyclejs/src/problems/p01/index_03.js`

``` js
...
  const vdom$ = xs.of(
    div([
      div("div01"),
      div("div02"),
    ])
``` 

<div class="app"><div><div>div01</div><div>div02</div></div></div>

Opt04: Reflection: what is the content of vdom$ 

Edit `ex/study_notes_cyclejs/src/problems/p01/index_04.js`

``` js
...
  const vdom$ = xs.of(
    div("div01"),
  )
  vdom$.addListener({
    next: x => {
      console.log(Reflect.ownKeys(x))
    },
  })
  ...
``` 

Also check: <url:/Users/mertnuhoglu/projects/study/js/study_js.Rmd#tn=## Reflection: Getting the Name of a Function>

Opt05: Use `debug` instead of `addListener`

Edit `ex/study_notes_cyclejs/src/problems/p01/index_05.js`

``` js
...
  const vdom$ = xs.of(
    div("div01"),
  ).debug(x => console.log(Reflect.ownKeys(x)))
``` 

Console:

    ["sel", "data", "children", "text", "elm", "key"]

Opt06: `state$.map` instead of `xs.of`

Edit `ex/study_notes_cyclejs/src/problems/p01/index_06.js`

``` js
...
  const state$ = xs.of({a: 1})
  const vdom$ = state$.map( (x) =>
    div(`div ${x.a}`),
  )
``` 

<div class="app"><div>div 1</div></div>

Opt07: Multiple div with `state$.map`

Edit `ex/study_notes_cyclejs/src/problems/p01/index_07.js`

``` js
...
  const vdom$ = state$.map( (x) =>
    div(`div${x.a}`),
    div(`div2`),
``` 

<div class="app"><div>div1</div></div>

Opt08: Use nested component

Edit `ex/study_notes_cyclejs/src/problems/p01/index_08.js`

``` js
...
function component(sources) {
  const state$ = xs.of({a: 1})
  const vdom$ = state$.map( (x) =>
    div(`div${x.a}`),
  )
	return {
		DOM: vdom$,
	};
}

function main(sources) {
	const c1 = component(sources)
  return {
    DOM: c1.DOM,
  };
}
``` 

<div class="app"><div>div1</div></div>

Opt09: use `isolate` for nested component

``` js
...
	const c1 = isolate(component)(sources)
...
``` 

<div class="app"><div>div1</div></div>

## p02: Debugging state$.map( ({body}) => table(..)) 

Opt01: Move files into sandbox

`ex/study_notes_cyclejs/src/problems/p02/v01`

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p02/v01/src/components/plan_panel/index.js`

``` js
...
	const panel_vdom$ = state$.map( ({body}) =>
		div("1"),
	)
``` 

Works well.

Opt02: Use body to reproduce the error

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p02/v02/src/components/plan_panel/index.js`

``` js
...
	const panel_vdom$ = state$.map( ({body}) =>
    body.map(e => "ali"),
	)
``` 

Error: browser output: `undefined`

### Opt03: debug()

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p02/v03/src/components/plan_panel/index.js`

``` js
...
	const panel_vdom$ = state$
		.debug( x => console.log(x))
    .debug( ({body}) => console.log(body))
    .map( ({body}) =>
      div([
        body.map(e => 
          div([
            td(e.plan_id),
          ])
        ),
      ])
    )
``` 

Console:

``` js
{body: Array(5)}body: Array(5)0: {plan_id: 1, usr: "usr_4_4_4_4_4_4", depot_id: 4}1: {plan_id: 2, usr: "usr_4_4_4_4_4_4", depot_id: 2}2: {plan_id: 3, usr: "usr_2_2_2_2_", depot_id: 5}3: {plan_id: 4, usr: "usr_1_1_1_1_1_1", depot_id: 3}4: {plan_id: 5, usr: "usr_1_1_1_1_1_1", depot_id: 3}length: 5__proto__: Array(0)__proto__: Object
(5) [{…}, {…}, {…}, {…}, {…}]
0 : {plan_id: 1, usr: "usr_4_4_4_4_4_4", depot_id: 4}
1 : {plan_id: 2, usr: "usr_4_4_4_4_4_4", depot_id: 2}
2 : {plan_id: 3, usr: "usr_2_2_2_2_", depot_id: 5}
3 : {plan_id: 4, usr: "usr_1_1_1_1_1_1", depot_id: 3}
4 : {plan_id: 5, usr: "usr_1_1_1_1_1_1", depot_id: 3}
length : 5
__proto__ : Array(0)
``` 

### Opt04_01: Reproduce the error with static data

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p02/v04/index_01.js`

``` js
...
function component(sources) {
	const state$ = xs.of({
		body: [
			{plan_id: 1, usr: "usr1", depot_id: 4},
			{plan_id: 2, usr: "usr2", depot_id: 2}
		]})
	const vdom$ = state$
		.debug( (x) => console.log(x))
		.map( ({body}) =>
			div([
				body.map(e => 
					div([
						td(e.plan_id),
					])
				),
			])
    ).debug( console.log )
``` 

Console:

``` js
{sel: "div", data: {…}, children: Array(1), text: undefined, elm: undefined, …}
``` 

### Opt04_02: Fix the error

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p02/v04/index_02.js`

``` js
...
    .map( ({body}) =>
      div(
        body.map(e => 
          div([
            div(e.plan_id),
          ])
        ),
      ),
    ).debug( console.log )
``` 

Console:

``` js
{sel: "div", data: {…}, children: Array(2), text: undefined, elm: undefined, …}
``` 

### Understand the Cause of the Error:

input:

    {body: Array(2)}
      0 : {plan_id: 1, usr: "usr_4_4_4_4_4_4", depot_id: 4}
      1 : {plan_id: 2, usr: "usr_4_4_4_4_4_4", depot_id: 2}

stream element: body

    0 : {plan_id: 1, usr: "usr_4_4_4_4_4_4", depot_id: 4}
    1 : {plan_id: 2, usr: "usr_4_4_4_4_4_4", depot_id: 2}

mapper 04_01

		.map( ({body}) =>
			div([
				body.map(e => 
					div([
						td(e.plan_id),

output 04_01

    div([
      [
        div([td(1)]),
        div([td(2)]),
      ]
    ])

mapper 04_02

    .map( ({body}) =>
      div(
        body.map(e => 
          div([
            div(e.plan_id),

output 04_02

    div([
      div([div(1)]),
      div([div(2)]),
    ])

Note that, output_04_01 has double nested array inside div: div([[div(..)]])

Double nested array cannot be rendered by browser.

### How To Find Out The Cause Of The Mistake

Put .debug() after map and check children.

    .debug( x => console.log(x.children) )

Or toHTML()
 
    var toHTML = require('snabbdom-to-html')
    global.toHTML = toHTML
    ...
    .debug( x => {
      global.x = x
      console.log(toHTML(x))
    } )
    // "<div><div></div></div>"

## p03: Multiple HTTP Requests id=g_10764


Opt01: Multiple Buttons

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/index_01.js`

The following xs.merge(..) streams don't work:

``` js
...
  const response$ = xs.merge(
    user$,
    todo$,
  )
    .debug(x => {
      console.log(x)
    })
  const vdom$ = xs.merge(
    userVdom$, 
    todoVdom$,
  )
    .debug(x => {
      console.log(x)
    })
    ...
``` 

There is no event at all after xs.merge

Cause: Use xs.combine() instead of xs.merge.

### Test xs.merge

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/merge_01.js`

``` js
const xs = require('xstream').default

var s1$ = xs.periodic(1000)
  .endWhen(xs.periodic(5000).take(1))

s1$.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})

``` 

Now, add a new stream:

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/merge_02.js`

``` js
var s1$ = xs.periodic(1000)
  .map(i => i * 2)
  .endWhen(xs.periodic(5000).take(1))
var s2$ = xs.periodic(1000)
  .map(i => i * 3)
  .endWhen(xs.periodic(5000).take(1))
var s3$ = xs.merge(s1$, s2$)

s3$.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})

``` 

``` bash
node problems/p03/merge_02.js
> 0
> 0
> 2
> 3
> 4
> 6
> 6
> 9
> completed
``` 

---

Opt02: Use xs.combine() instead of xs.merge.

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/index_02.js`

``` js
...
  const vdom$ = xs.combine(
    userVdom$, 
    todoVdom$,
  )
    .map( ([user, todo]) =>
      div([
        user,
        todo,
      ])
    )
    ...
``` 

Opt03: Make intent return both requests

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/index_03.js`

``` js
function intent(sources) {
  ...
  return xs.merge(getRandomUser$, getTodo$)
``` 

The output:

<div class="app"><div><div class="users"><button class="get-random">Get user</button><div class="user-details"><h1 class="user-name">Leanne Graham</h1><a class="user-website" href="hildegard.org">hildegard.org</a></div></div><div class="todos"><button class="get-todo">Get todo</button><div class="todo-details"><h1 class="todo-title">delectus aut autem</h1></div></div></div></div>

Opt04: Structure as intent model view functions

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/index_04.js`

``` js
function main(sources) {
  const requests$ = intent(sources)
  const {user$, todo$} = model(sources)
  const vdom$ = view({user$, todo$})
  return {
    DOM: vdom$,
    HTTP: requests$,
  };
}
...
``` 

Opt05: Call the REST Services when Loading the Web Page

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/index_05.js`

``` js
...
function intent(sources) {
  const getRandomUser$ = xs.of(
    {
      url: 'https://jsonplaceholder.typicode.com/users/1',
      category: 'users',
      method: 'GET',
    }
  )
  const getTodo$ = xs.of(
    {
      url: 'https://jsonplaceholder.typicode.com/todos/1',
      category: 'todos',
      method: 'GET',
    }
  )
  return xs.merge(getRandomUser$, getTodo$)
}
``` 

Opt06: Use xs.from

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/index_06.js`

``` js
function intent(sources) {
  const requests$ = xs.from(
    [
      {
        url: 'https://jsonplaceholder.typicode.com/users/1',
        ...
    ]
  )
  return requests$
}
``` 

Opt08: Call REST services without view

``` js
function main(sources) {
  const requests$ = intent(sources)
  const {user$, todo$} = model(sources)
  const userVdom$ = user$.map( user => 
    user
  )
  const todoVdom$ = todo$.map( todo =>
    todo
  )
  userVdom$.addListener({
    next: x => console.log(x),
  })
  todoVdom$.addListener({
    next: x => console.log(x),
  })
  return {
    HTTP: requests$,
  };
}
``` 

Opt07: Call my REST Services without view

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/index_07.js`

``` js
  const requests$ = xs.from(
    [
      {
        url: 'http://localhost:8080/rest/plan?select=plan_id,usr,depot_id',
        ...
      {
        url: 'http://localhost:8080/rest/purchase_order?select=purchase_order_id,company_id,order_extid,company_extid',
        ...
``` 

Opt09: Call my REST Services with view

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p03/index_09.js`

``` bash
cd ex/study_notes_cyclejs/
npm run p03_09
``` 

``` js
function view(state) {
  const {user$, todo$} = state
  const userVdom$ = user$
    .map( users =>
      div(
        users === null ? "" : users.map( user =>
          div(user.usr)
        )
      ),
    )

  const todoVdom$ = todo$
    .map( todos =>
      div(
        todos === null ? "" : todos.map( todo =>
          div(todo.purchase_order_id)
        )
      ),
    )
  const vdom$ = xs.combine(
    userVdom$, 
    todoVdom$,
  )
    .map( ([user, todo]) =>
      div([
        user,
        todo,
      ])
    )
  return vdom$
}
``` 

It works. 

## p04: CycleJs without Bundlers and Transpilers like ParcelJs

I wonder if not using bundlers will make debugging easier? Because sometimes the bundler and transpiler makes the code so obfuscated that chrome's source mapping doesn't work correctly.

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p04/index.js`

This seems too difficult to try.

## p05: Multiple HTTP Requests Using Multiple Components

Started from `<url:/Users/mertnuhoglu/projects/study/js/vrp/cyclejs_vrp.Rmd#tn=### v15.07: standardize isolate() and sinks.DOM for subcomponents part 2>`

Opt01: Complex App: Multiple Components + Onion + Single HTTP Request + Hot

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex01/index.js`

Opt01b: Move Hot sinks to DetailPanel: Multiple Components + Onion + Single HTTP Request + Hot

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex01b/index.js`

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex01b/components/app/index.js`

``` js
...
  const hot$ = detailPanelSinks.Hot
  return {
    Hot: hot$,
``` 

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex01b/components/detail_panel/index.js`

``` js
...
  const sinks = {
    Hot: xs.periodic(2000)
    .take(1)
    .map(i => data1),
``` 

Opt01b02: Use state$ as Hot data: Multiple Components + Onion + Single HTTP Request + Hot

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex01b02/index.js`

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex01b02/components/detail_panel/index.js`

``` js
...
  const sinks = {
    Hot: state$
    .map( ({body}) => body )
    .map( xs => xs.map( y => Object.keys(y).map( key => y[key] ) )),
``` 

Opt02: Remove Onion and Hot from Complex App: Multiple Components + Single HTTP Request

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex02/index.js`

Opt03: Add Multiple HTTP Requests to Complex App: Multiple Components + Multiple HTTP Requests

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex03/index.js`

Opt04: Add Hot and pipe its data from model(): Multiple Components + Multiple HTTP + Hot pipeline

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex04/index.js`

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex04/components/app/index.js`

``` js
...
  const hot$ = detailPanelSinks.Hot
  return {
    DOM: vdom$,
    HTTP: intent(sources),
    Hot: hot$,
``` 

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p05/ex04/components/detail_panel/index.js`

``` js
export default function DetailPanel(sources, purchase_order$) {
  const state$ = purchase_order$
  ...
  const sinks = {
    DOM: panel_vdom$,
    Hot: state$
    .map( xs => xs.map( y => Object.keys(y).map( key => y[key] ) )),
``` 

## p06: xstream.compose function

`imitate` allows circular dependency of streams

``` bash
node ex/study_notes_cyclejs/src/problems/p06/ex02.js
``` 

Edit `ex/study_notes_cyclejs/src/problems/p06/ex02.js`

``` js
const xs = require('xstream').default
const delay = require('xstream/extra/delay').default

var secondProxy$ = xs.create();
var first$ = secondProxy$.map(x => x * 10).take(3);
var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
secondProxy$.imitate(second$);

second$.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})
//> 1
//> 11
//> 111
//> 1111
//> completed
``` 

If we remove `secondProxy$.imitate(second$);` what happens?

Edit `ex/study_notes_cyclejs/src/problems/p06/ex03.js`

``` js
var secondProxy$ = xs.create();
var first$ = secondProxy$.map(x => x * 10).take(3);
var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));
//> 1
``` 

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p06/ex05.js`

``` js
const input = xs.of(1, 2, 3, 4)
const out = input.compose(delay(500))
//> 1
//> 2
//> 3
//> 4
//> completed
``` 

## p07: Sample Apps for Master-Detail Relationships

ex01: Static view is rendered

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex01/index.js`

``` js
...
  const state$ = xs.of([
    {"item_id": 1, "title": "item01"},
    {"item_id": 2, "title": "item02"},
  ])
  const vdom$ = view(state$)
... 
function view(state$) {
  return state$.map( (state) => {
    const items = state
    return div([
      section(".new_item", [
        input(".new_item_title"),
        button(".new_item_submit", "Add Item"),
      ]), 
      section(".item_list",        
        items.map( (item) =>
          div(".item",[
            span(".item_title", `${item.title}`),
            button(".remove_item", {dataset: {item_id: item.item_id}}, `Remove ${item.item_id}`),
          ]),
        ) 
      )
    ])
  }
  )
}
``` 

Check if `click` actions work:

``` js
function intent(dom$) {
  const newItem$ = dom$.select('.new_item_submit').events('click')
    .mapTo({type: "NEW_ITEM"})
    .debug()
  const removeItem$ = dom$.select('.remove_item').events('click')
    .map((e) => ({type: "REMOVE_ITEM", payload: e.target.dataset.item_id}))
    .debug()
  return {newItem$, removeItem$ }
}
...
  const actions = intent(sources.DOM)
  actions.newItem$.addListener({
    next: data => {
      console.log("newItem$")
      console.log(data)
    }})
``` 

Note that, in order for this to work, we need to add addListener to `actions.newItem$` streams. Otherwise the stream's producer doesn't start at all.

### Ex03: Pipe actions to model()

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex03/index.js`

``` js
  const actions = intent(sources.DOM)
  const reducers = model(actions)
  addListener(reducers)
  const state2$ = xs.merge(...reducers)
    .fold((listItems, reducer) => reducer(listItems), {"initial": 0});
  addListenerStream(state2$, "state2$")
``` 

``` js
function model(actions) {
  const newItem$ = actions.newItem$.map(function newItemReducer(prevState){
    return {"item_id": 3, "title": "item03"}
  })
  addListenerStream(newItem$, "model.newItem$")
  const removeItem$ = actions.removeItem$.map(function removeItemReducer(prevState) {
    return {}
  })
  return {newItem$, removeItem$}
}
``` 

Now, clicking the buttons will pipe events until model(). But model's responses are not piped to view() yet:

``` js
  const state$ = xs.of([
    {"item_id": 1, "title": "item01"},
    {"item_id": 2, "title": "item02"},
  ])
  const vdom$ = view(state$)
``` 

### Ex03a: Why does `model.newItem$` stream return the response object instead of the reducer function?

In the logs, I should get `function` events instead of the returning results of the function invocations. 

``` js
model.newItem$
index.js:1744 {item_id: 3, title: "item03"}
``` 

The cause of this unexpected behaviour lies with the reducer function definitions:

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex03a/index.js`

``` js
  const newItem$ = actions.newItem$.map(function newItemReducer(prevState){
    console.log("inside newItemReducer")
    return {"item_id": 3, "title": "item03"}
  })
``` 

This reducer returns the object `{"item_id": 3, "title": "item03"}` instead of the function `newItemReducer`. Correct reducer is the following:

``` js
  const newItem$ = actions.newItem$.mapTo(function newItemReducer(prevState){
    console.log("inside newItemReducer")
    return {"item_id": 3, "title": "item03"}
  })
``` 

### Ex04: Pipe model's response to view:

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex04/index.js`

``` js
  const reducers = model(actions)
  const state$ = xs.merge(...reducers)
    .fold((listItems, reducer) => reducer(listItems), seeds)
    .startWith(seeds)
  const vdom$ = view(state$)
``` 

When I first run this, there was no event coming from state$ stream. The reason for this was the spread operator for object properties does not work properly without babel plugin. To solve the problem, I added the spread operator plugin to package.json:

``` js
    "babel-preset-env": "^1.7.0",
    "babel-plugin-transform-object-rest-spread": "^6.6.5",
    "babel-preset-es2015": "^6.3.13",
    "babel-register": "^6.4.3",
    "babelify": "^7.2.0",
``` 

And I put these lines into `~/codes/js/todomvc-cycle-onion/.babelrc`:

``` js
{
  "presets": ["es2015"],
  "plugins": ["transform-object-rest-spread"]
}
``` 

### Ex05: Use onion instead of your own reducer fold function:

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex05/index.js`

Instead of my own custom reducer fold expression, use onion:

``` js
  //const state$ = xs.merge(...reducers)
    //.fold((listItems, reducer) => reducer(listItems), seeds)
    //.startWith(seeds)
``` 

Now this becomes:

``` js
const initReducer$ = xs.of(function initReducer() {
  return seeds;
})
...
  const reducer$ = xs.merge(initReducer$, ...reducers)
  const state$ = sources.onion.state$
  const vdom$ = view(state$)
  return {
    DOM: vdom$,
    onion: reducer$,
  };
``` 

Unexpected behaviour with xs.merge:

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex05/index01.js`

We merge initial reducer stream with other reducer streams. But the order of merging stream arguments change the behaviour of the final stream.

The following works sometimes:

``` js
  const reducer$ = xs.merge(initReducer$, ...reducers)
``` 

But the following merge expressions don't work:

``` js
  const reducer$ = xs.merge(initReducer$, reducers.newItem$)
  const reducer$ = xs.merge(reducers.newItem$, initReducer$)
``` 

But if I add `startWith` to them, then they work too:

``` js
  const reducer$ = xs.merge(initReducer$, reducers.newItem$)
    .startWith(initReducer$)
  const reducer$ = xs.merge(reducers.newItem$, initReducer$)
    .startWith(initReducer$)
``` 

I didn't understand why sometimes they work and sometimes don't. Maybe it is an issue with parceljs bundler.

I will always use `startWith` in order to assure proper working. 

Now this didn't work:

``` js
  const reducer$ = xs.merge(initReducer$, reducers.newItem$)
    .startWith(initReducer$)
``` 

And commenting startWith works:

``` js
  const reducer$ = xs.merge(initReducer$, reducers.newItem$)
``` 

My choice: Never use spread operator in xs.merge.

Another related oddity is that `startWith` works only if `addListenerStream` is called. For example, the following works:

``` js
  const reducer$ = xs.merge(initReducer$, reducers.newItem$)
    .startWith(initReducer$)
  addListenerStream(reducer$, "reducer$")
``` 

But every click causes to add two new items.

When I comment `addListenerStream` then nothing is rendered. 

When I remove both `addListenerStream` and `startWith` then it works correctly.

### Ex06: Making new items from the input content

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex06/index.js`

First, I tried to use `sampleCombine` operator:

``` js
  const updateInput$ = dom$.select('.new_item_title').events('input')
    .map(ev => ev.target.value.trim())
  const submit$ = dom$.select('.new_item_submit').events('click')
    .mapTo({type: "NEW_ITEM"})
  const newItem$ = updateInput$.compose(sampleCombine(submit$))
    .map( ([title, submit]) => title)
``` 

This fires a new event after each key typing. This is not what I want. I want to fire a new event only after clicking `submit` button.

Then, I tried to use `combine` operator:

``` js
  const newItem$ = xs.combine(updateInput$, submit$)
    .map( ([title, submit]) => title)
``` 

This fires a new event after each key typing too. 

Then, I tried to use `sampleCombine` again but this time I reversed the order of input streams:

``` js
  var newItem$ = submit$.compose(sampleCombine(updateInput$))
    .map( ([submit, input]) => input )
``` 

Now, it works as expected. 

### Ex07: Define an id generator and assign id to new items

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex07/index.js`

Initial state now contains max id number:

``` js
const initState = {
  max_id: 2,
  items: [
    {"item_id": 1, "title": "item01"},
    {"item_id": 2, "title": "item02"},
  ],
}
const initReducer$ = xs.of(function initReducer() {
  return initState
})
``` 

Since the structure of the state object changed, we need to update reducer functions as well:

``` js
...
    function newItemReducer(prevState){
      return {        
        max_id: prevState.max_id + 1,
        items: [
          ...prevState.items,
          {"item_id": (prevState.max_id + 1), "title": title},
        ]}
``` 

### Ex08: Remove items

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex08/index.js`

``` js
  const removeItem$ = actions.removeItem$.map(action => function removeItemReducer(prevState) {
    return {
      ...prevState,
      items: prevState.items.filter(item => item.item_id !== +action.payload)
    }
``` 

## p08: How to make data flow model from the code?

Example 01: <url:file:///~/codes/js/front-end-reactive-architectures/9781484231791/examples/weather-onionify/src/CityForm.js>

``` js
  const getRequest = city => ({
          type: CITY_SEARCH,
          city: city,
          url: `http://api.apixu.com/v1/forecast.json?key=04ca1fa2705645e4830214415172307&q=${city}&days=7`,
          category: CATEGORY
  })
  ...
  const intent = DOM => {
    return xs.combine(input$, btn$)
             .map(([city, mouseEvt]) => getRequest(city))
             .startWith(getRequest(INIT_CITY))
  ...
  const actions$ = intent(sources.DOM);
  ...
  return { HTTP: actions$ }
  ...
  const reducer$ = model(sources.HTTP);
  ...
  const model = (HTTP) => {
    return HTTP.map(...)
  ...
  return { onion: reducer$, }
``` 

    0:sources.DOM -> 1:[intent] -> 2:sinks.HTTP -> 3:[HTTPDriver] -> 4:sources.HTTP -> 5:[model] -> 6:reducer$ -> 7:[onion] -> 8:state$ -> 9:[view] -> 10:vdom$ -> 11:[DOMDriver] -> (0)
    6: sinks.onion = reducer$
    8: state$ = sources.onion.state$
    10: sinks.DOM = vdom$

Example 02: <url:/Users/mertnuhoglu/codes/js/cyclejs/examples/advanced/many/src/List.js#tn=function List(sources) {>

``` js
  const proxyItemRemove$ = xs.create();
  const action$ = intent(sources.DOM, proxyItemRemove$);
  const itemWrapper = makeItemWrapper(sources.DOM);
  const items$ = model(action$, itemWrapper);
  const itemRemove$ = items$
    .map(items => xs.merge(...items.map(item => item.Remove)))
    .flatten()
  proxyItemRemove$.imitate(itemRemove$);
  const vtree$ = view(items$);
``` 

    <url:/Users/mertnuhoglu/projects/study/js/study_cyclejs_examples.Rmd#tn=## Data Flow of List-Item>

## p09: Textual representation of the data flow models:

opt01: linear flow sequence

    (0)sources.DOM -> [intent] -> sinks.HTTP -> [HTTPDriver] -> sources.HTTP -> [model] -> reducer$ -> [onion] -> state$ -> [view] -> sinks.DOM -> [DOMDriver] -> (0)

opt02: give each element an id number

    0:sources.DOM -> 1:[intent] -> 2:sinks.HTTP -> 3:[HTTPDriver] -> 4:sources.HTTP -> 5:[model] -> 6:reducer$ -> 7:[onion] -> 8:state$ -> 9:[view] -> 10:sinks.DOM -> 11:[DOMDriver] -> (0)

opt03: branches represented by using new flow sequences

    0:sources.DOM -> 1:[intent] -> 2:sinks.HTTP -> 3:[HTTPDriver] -> 4:sources.HTTP -> 5:[model] -> 6:reducer$ -> 7:[onion] -> 8:state$ -> 9:[view] -> 10:sinks.DOM -> 11:[DOMDriver] -> (0)
    1:[intent] -> 12:actions$ -> 5:[model]

opt04: names as attributes

    0:sources.DOM -> 1:[intent] -> 2:sinks.HTTP -> 3:[HTTPDriver] -> 4:sources.HTTP -> 5:[model] -> 6:reducer$ -> 7:[onion] -> 8:state$ -> 9:[view] -> 10:sinks.DOM -> 11:[DOMDriver] -> (0)
    0:_n:DOMSource
    2:_n:actions

opt05: what if we have encapsulating objects as elements?

    2:actions
    2:_n:{HTTP, newItem$}

opt06: what if we want to explicitly show that HTTP goes into sinks?

    2:sinks.HTTP
    2:HTTP

    2:_n:sinks.HTTP

    2:actions
    2:_n:{HTTP, newItem$}
    2:_e: sinks.HTTP = actions.HTTP

    2: actions = {HTTP, newItem$}
    2: sinks.HTTP = actions.HTTP

choose: opt06.d, opt06.b, opt03

## p10: form submit için bir operatör tanımlama

Ex01:

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p10/ex01.js`

Ex04: Reverse the input stream arguments

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p10/ex04.js`

``` js
// s1:  -0-1-2-3|
// s2:  ---0---1|
// res: ---1---3|
const s1 = xs.periodic(250).take(4)
  .debug()
const s2 = xs.periodic(510).take(2)
  .debug()

const res = s2.compose(sampleCombine(s1))
  .map( ([v2, v1]) => v1 )
// 0
// 1
// 0
// res: 1
// 2
// 3
// 1
// res: 3
// res completed
``` 

## p11: Numerical simulation using xstream

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p11/ex01.js`

``` js
const ticks = xs.periodic(100).take(100)
// pop(t) = 0.05 * dt * pop(t-1) + pop(t-1)
const population = ticks.fold((acc,cur) =>
  0.05 * 0.1 * acc + acc,
  100
)
// pop: 100
// pop: 100.5
// pop: 101.0025
// pop: 101.5075125
// pop: 102.01505006250001
// ...
``` 

## p12: Convert two substreams of state into a single stream of state

Problem from: <url:/Users/mertnuhoglu/projects/study/js/vrp/cyclejs_vrp.Rmd#tn=#### v15.09_01: Make state non-stream object>

Currently state stream consists of two substate-streams:

``` js
  const {plans$, purchase_orders$} = state$
``` 

I want to obtain only one stream of global state. 

`plans$` and `purchase_orders$` are streams of the following arrays:

``` js
[
  { "plan_id": 1, "usr": "usr_4_4_4_4_4_4", "depot_id": 4 },
  { "plan_id": 2, "usr": "usr_4_4_4_4_4_4", "depot_id": 2 }
]
``` 

``` js
[
  { "purchase_order_id": 1, "company_id": 2, "order_extid": "order_extid_2", "company_extid": "company_e" },
  { "purchase_order_id": 2, "company_id": 5, "order_extid": "order_extid_2", "company_extid": "company_e" }
]
``` 

Now, how can we convert these streams into a single state object of the form:

``` js
{
  plans: [{..}, {..}, ...],
  purchase_orders: [{..}, {..}, ...],
}
``` 

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p12/ex01.js`

``` js
const rs$ = xs.combine(plans$, purchase_orders$)
  .map( ([plans, purchase_orders]) => ({
    plans: plans,
    purchase_orders: purchase_orders,
  }))
// result: {"plans":[{"plan_id":1,"usr":"usr_4_4_4_4_4_4","depot_id":4},{"plan_id":2,"usr":"usr_4_4_4_4_4_4","depot_id":2}],"purchase_orders":[{"purchase_order_id":1,"company_id":2,"order_extid":"order_extid_2","company_extid":"company_e"},{"purchase_order_id":2,"company_id":5,"order_extid":"order_extid_2","company_extid":"company_e"}]}
``` 

## p13: Make HTTP Requests in nodejs with xstream

My ultimate goal is to test everything inside a normal GUI application first in the nodejs side. Lastly, I was about to convert a state object returning model() function to a reducer returning function. From `<url:/Users/mertnuhoglu/projects/study/js/vrp/cyclejs_vrp.Rmd#tn=### v15.09_02 Return reducers from model()>`

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p13/ex01.js`

``` js
const {makeHTTPDriver} = require('@cycle/http')
const xs = require('xstream').default

const HTTP = makeHTTPDriver()
const requests$ = xs.from(
  [
    {
      url: 'http://localhost:8080/rest/plan?select=plan_id,usr,depot_id',
      method: 'GET',
      headers: {
        "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJyb2xlIjoid2VidXNlciJ9.uSsS2cukBlM6QXe4Y0H90fsdkJSGcle9b7p_kMV1Ymk"
      },
      category: 'plan',
    },
  ]
)
const httpSource = HTTP(requests$)

const plans$ = httpSource.select('plan')
  .flatten()
  .map(res => 
    res.body
  )
// result: [{"plan_id":1,"usr":"usr_4_4_4_4_4_4","depot_id":4},{"plan_id":2,"usr":"usr_4_4_4_4_4_4","depot_id":2},{"plan_id":3,"usr":"usr_2_2_2_2_","depot_id":5},{"plan_id":4,"usr":"usr_1_1_1_1_1_1","depot_id":3},{"plan_id":5,"usr":"usr_1_1_1_1_1_1","depot_id":3}]
// s1 completed
``` 

Run 

``` js
cd ~/projects/study/js/ex/study_notes_cyclejs/
node src/problems/p13/ex01.js
'# result: [{"plan_id":1,"usr":"usr_5_5_5_5_","depot_id":3},{"plan_id":2,"usr":"usr_1_1_1_1_1_1","depot_id":1},{"plan_id":3,"usr":"usr_5_5_5_5_","depot_id":1},{"plan_id":4,"usr":"usr_5_5_5_5_","depot_id":1},{"plan_id":5,"usr":"usr_4_4_4_4_4_4","depot_id":2}]
``` 

## p14: Converting state returning model() function to reducer returning function

From `<url:/Users/mertnuhoglu/projects/study/js/vrp/cyclejs_vrp.Rmd#tn=### v15.09_02 Return reducers from model()>`

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p14/ex01.js`

``` js
const planReducer$ = httpSource.select('plan')
  .flatten()
  .map(res => function planReducer(prevState) {
    return res.body
  })

const state$ = xs.merge(planReducer$)
  .fold((prevState, reducer) => reducer(prevState), {});
// result: {}
// result: [{"plan_id":1,"usr":"usr_4_4_4_4_4_4","depot_id":4},{"plan_id":2,"usr":"usr_4_4_4_4_4_4","depot_id":2},{"plan_id":3,"usr":"usr_2_2_2_2_","depot_id":5},{"plan_id":4,"usr":"usr_1_1_1_1_1_1","depot_id":3},{"plan_id":5,"usr":"usr_1_1_1_1_1_1","depot_id":3}]
// s1 completed
``` 

Now, let's do this with combined results.

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p14/ex02.js`

``` js
const requests$ = intent()
const httpSource = HTTP(requests$)

const initialState = {
  plans: [], 
  purchase_orders: [],
}
const planReducer$ = httpSource.select('plan')
  .flatten()
  .map(res => function planReducer(prevState) {
    return {
      ...prevState,
      plans: res.body
    }
  })
const purchaseOrderReducer$ = httpSource.select('purchase_order')
  .flatten()
  .map(res => function purchaseOrderReducer(prevState) {
    return {
      ...prevState,
      purchase_orders: res.body
    }
  })
const reducer$ = xs.merge(planReducer$, purchaseOrderReducer$)

const state$ = reducer$
  .fold((prevState, reducer) => reducer(prevState), initialState);
// result: {"plans":[],"purchase_orders":[]}
// result: {"plans":[{"plan_id":1,"usr":"usr_4_4_4_4_4_4","depot_id":4},{"plan_id":2,"usr":"...
// result: {"plans":[{"plan_id":1,"usr":"usr_4_4_4_4_4_4","depot_id":4},{"plan_id":2,"usr"...
``` 

Note that, we deleted `xs.combine` expression completely. `fold` replaces the need for `combine`. At each folding iteration, the `prevState` is combined with current `reducer`'s response. 

## p15: Converting reducer$.fold to onion

From `<url:/Users/mertnuhoglu/projects/study/js/vrp/cyclejs_vrp.Rmd#tn=### v15.09_02 Return reducers from model()>`

### p15 ex01

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p15/ex01.js`

``` js
function intent() {
  const requests$ = xs.from(
    [
      {
        url: 'http://localhost:8080/rest/plan?select=plan_id,usr,depot_id',
        method: 'GET',
        headers: {
          "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJyb2xlIjoid2VidXNlciJ9.uSsS2cukBlM6QXe4Y0H90fsdkJSGcle9b7p_kMV1Ymk"
        },
        category: 'plan',
      },
    ]
  )
  return requests$
}
const requests$ = intent()
const HTTP = makeHTTPDriver()
const httpSource = HTTP(requests$)

function model(httpSource) {
  const planReducer$ = httpSource.select('plan')
    .flatten()
    .map(res => function planReducer(prevState) {
      return res.body
    })
  return planReducer$
}
const reducer$ = model(httpSource)

function onion(reducer$) {
  const state$ = xs.merge(reducer$)
    .fold((prevState, reducer) => reducer(prevState), {});
  return state$
}
const state$ = onion(reducer$)
``` 

I reorganized the existing expressions into separate functions. 

### p15 ex02

Now, let's use onionify `main()` function.

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p15/ex02.js`

``` js
...
function main() {
  const requests$ = intent()
  const HTTP = makeHTTPDriver()
  const httpSource = HTTP(requests$)
  const reducer$ = model(httpSource)
  return reducer$
}
function onionify(main) {
  return function mainOnionified() {
    const reducer$ = main()
    const state$ = onion(reducer$)
    return state$
  }
}
const mainOnionified = onionify(main);
const state$ = mainOnionified()
``` 

### p15 ex03

Now, let's use cycle's own `onionify()`.

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p15/ex03.js`

``` js
const onionify = require('cycle-onionify').default
...
function main(sources) {
  const requests$ = intent()
  const HTTP = makeHTTPDriver()
  const httpSource = HTTP(requests$)
  const reducer$ = model(httpSource)
  const state$ = sources.onion.state$
  return {
    onion: reducer$,
    state$: state$
  }
}
//function onionify(main) {
  //return function mainOnionified() {
    //const reducer$ = main()
    //const state$ = onion(reducer$)
    //return state$
  //}
//}
const mainOnionified = onionify(main);
const sources = {}
const state$ = mainOnionified(sources).state$
``` 

### p15 ex04

Now, let's make our own `onionify()` more similar to `cyclejs.onionify()`.

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p15/ex04.js`

``` js
function onion(reducer$) {
  const state$ = xs.merge(reducer$)
    .fold((prevState, reducer) => reducer(prevState), initialState);
  return state$
}
function main(sources) {
  const requests$ = intent()
  const HTTP = makeHTTPDriver()
  const httpSource = HTTP(requests$)
  const reducer$ = model(httpSource)
  const state$ = sources.onion.state$
  return {
    onion: reducer$,
    state$: state$,
  }
}
function onionify(main) {
  return function mainOnionified(sources) {
    const reducerMimic$ = xs.create()
    const state$ = onion(reducerMimic$)
    sources.onion = {state$}
    const sinks = main(sources)
    reducerMimic$.imitate(sinks.onion)
    return sinks
  }
}
const mainOnionified = onionify(main);
const sources = {}
const state$ = mainOnionified(sources).state$
``` 

### p15 ex05

Now, let's initialize state with initialState.

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p15/ex05.js`

``` js
function model(httpSource) {
  const initReducer$ = xs.of(
    function initReducer(prevState) {
      const initialState = {
        plans: [], 
        purchase_orders: [],
      }
      return initialState
    }
  )
  const planReducer$ = httpSource.select('plan')
    .flatten()
    .map(res => function planReducer(prevState) {
      return {
        ...prevState, 
        plans: res.body
      }
    })
  return xs.merge(initReducer$, planReducer$)
}
...
// result: {"plans":[],"purchase_orders":[]}
// result: {"plans":[{"plan_id":1,"usr":"usr_4_4_4_4_4_4","depot_id":4},{"plan_id":2,"usr":"usr_4_4_4_4_4_4","depot_id":2},{"plan_id":3,"usr":"usr_2_2_2_2_","depot_id":5},{"plan_id":4,"usr":"usr_1_1_1_1_1_1","depot_id":3},{"plan_id":5,"usr":"usr_1_1_1_1_1_1","depot_id":3}],"purchase_orders":[]}
``` 

## p16: onion with one subcomponent and lens id=g_10221

I want to mimic a web app that has a parent component and a subcomponent where the subcomponent accesses the global state using a lens object. 

### p16.01 Creating subcomponent. Uses `cycle-onionify.onionify()`

Here I have only setup two files, one parent component and one subcomponent.

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex01.js`

``` js
const sub = require('./ex01_sub').default
...
function main(sources) {
  const component = sub
``` 

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex01_sub.js`

``` js
function main() {
  console.log("inside sub")
}

exports.main = main
``` 

### p16.02 Pass the global state to subcomponent. Custom `isolate()` with `cycle-onionify.onionify()`

### p16.02a Bug:

Run `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex02a.js`

``` bash
/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex02.js:96
state$.addListener({
       ^

TypeError: Cannot read property 'addListener' of undefined
``` 

This error shows that component() is not side-effect free.

Where do we introduce side-effect?

``` js
function isolateAllSources(outerSources, lens) {
  const innerSources = outerSources
  innerSources.onion = outerSources.onion.state$.map(lens.get)
``` 

In this line, we actually change the `sources` input from parent component. 

Solution:

``` js
function isolateAllSources(outerSources, lens) {
  const innerSources = {}
  for (const channel in outerSources) {
    innerSources[channel] = outerSources[channel]
  }
  innerSources.onion.state$ = outerSources.onion.state$.map(lens.get)
  return innerSources
}
``` 

But this time, subcomponent's onion.state$ will replace parent's onion.state$. So, I decouple subcomponent's onion from parent component's onion:

``` js
function isolateAllSources(outerSources, lens) {
  const innerSources = {}
  for (const channel in outerSources) {
    innerSources[channel] = outerSources[channel]
  }
  innerSources.onion = {}
  innerSources.onion.state$ = outerSources.onion.state$.map(lens.get)
  return innerSources
}
``` 

### p16.02: Correct implementation

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex02.js`

``` js
function isolate(component, lens) {
  // lens = scope
  return function wrappedComponent(outerSources) {
    const innerSources = isolateAllSources(outerSources, lens)
    //const innerSources = isolateAllSources({onion: {state$ : xs.create()}}, lens)
    const innerSinks = component(innerSources)
    const outerSinks = isolateAllSinks(outerSources, innerSinks, lens)
    return outerSinks
  }
}
function isolateAllSources(outerSources, lens) {
  const innerSources = {}
  for (const channel in outerSources) {
    innerSources[channel] = outerSources[channel]
  }
  innerSources.onion = {}
  innerSources.onion.state$ = outerSources.onion.state$.map(lens.get)
  return innerSources
}
function isolateAllSinks(outerSources, innerSinks, lens) {
  const innerReducer$ = innerSinks.onion
  const outerReducer$ = innerReducer$.map( innerReducer =>
    function outerReducer(outer) {
      // outer = prevState of App
      // prevInner = prevState of component
      const prevInner = lens.get(outer)
      const nextInner = innerReducer(prevInner)
      return lens.set(outer, nextInner)
    }
  )
  const outerSinks = innerSinks
  outerSinks.onion = outerReducer$
  return outerSinks
}
``` 

Now, instantiate the subcomponent:

``` js
function main(sources) {
  const component = isolate(sub, subLens)
  component(sources)
  ...
``` 

The lens of subcomponent doesn't make any modification on global state. Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex02_sub.js`

``` js
const subLens = {
  get: (state) => ({
    ...state,
    sub: 1,
  }),
  set: (state, childState) => ({
    ...state,
  })
}
``` 

### p16.03 Refactoring: Move isolate and onion functions to external module:

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex03_isolate.js`

``` js
...
exports.isolate = isolate
``` 

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex03.js`

``` js
const {isolate} = require('./ex03_isolate')
...
``` 

### p16.04 Customize the data using lenses

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex04_sub.js`

``` js
const subLens = {
  get: (state) => ({
    ...state,
    firstPlan: state.plans.filter(plan => plan.plan_id === 1),
  }),
``` 

### p16.05 Setting up run() method

Currently, I setup the sources and sinks inside main() function. Let's move them outside and encapsulate into a separate run() function:

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex05.js`

``` js
const {run} = require('@cycle/run')
function main(sources) {
  const component = isolate(sub, subLens)
  const requests$ = intent()
  //const HTTP = makeHTTPDriver()
  //const httpSource = HTTP(requests$)
  const {onion: subReducer$} = component(sources)
  ...
}
const mainOnionified = onionify(main);
run(mainOnionified, {
  HTTP: makeHTTPDriver(),
})
``` 

#### p16.05a Run app without Cyclejs.run()

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex05a.js`

``` js
const HTTP = makeHTTPDriver()
const mainOnionified = onionify(main);

const proxyHTTPSource = xs.from([{url: null, method: null}])
//const httpSource = HTTP(proxyHTTPSource)
const httpSource = HTTP(intent())
const sources = {HTTP: httpSource}
const sinks = mainOnionified(sources)
proxyHTTPSource.imitate(sinks.HTTP)
``` 

This didn't work.

#### p16.05b Implement Cyclejs.run() by my own

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex05b.js`

``` js
function run(main, drivers) {
  const proxySources = {}
  Object.keys(drivers).forEach(key => {
    proxySources[key] = new xs.create();
  })
  const sinks = main(proxySources);
  Object.keys(drivers).forEach(key => {
    const source = drivers[key](sinks[key]);
    source.subscribe(x => proxySources[key].next(x));
  })
}
``` 

This didn't work yet.


### p16.06 Subcomponent changes global state using setter lens

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex06.js`

``` js
const isolate = require('@cycle/isolate').default
...
  const component = isolate(sub, {onion: subLens})(sources)
  const parentReducer$ = model(httpSource)
  const reducer$ = xs.merge(parentReducer$, subReducer$)
``` 

Add initial state to component:

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex06_sub.js`

``` js
function model(httpSource) {
  const initialReducer$ = xs.of( prevState => ({
    firstPlan: {},
  }))
  const firstPlanReducer$ = httpSource.select('purchase_order')
    .flatten()
    .map( value => function firstPlanReducer(prevState) {
      return {
        ...prevState,
      }
    })
  return xs.merge(firstPlanReducer$)
}
``` 

Moreover, pipe sources.HTTP to component:

``` js
function main(sources) {
...
  const reducer$ = model(sources.HTTP)
``` 

Also, return `requests$` from component to app:

``` js
function main(sources) {
  const requests$ = intent()
  ...
  return {
    onion: reducer$,
    HTTP: requests$,
``` 

Then merge these requests with App's own requests in ex06.js

``` js
function main(sources) {
  const component = isolate(sub, {onion: subLens})(sources)

  const parentRequests$ = intent()
  const requests$ = xs.merge(parentRequests$, component.HTTP)
  ...
  return {
    onion: reducer$,
    state$: state$,
    HTTP: requests$,
``` 

### p16.07 Convert js to typescript

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex07.ts`

I didn't make any changes except import statements:

``` js
import {makeHTTPDriver} from '@cycle/http'
import xs from 'xstream'
import onionify from 'cycle-onionify'
import {main as sub, subLens} from './ex07_sub'
import isolate from '@cycle/isolate'
import {run} from '@cycle/run'
...
``` 

### p16.08 Add type annotations

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex08.ts`

``` js
...
function model(httpSource): xs<Reducer> {
  const initReducer$: xs<Reducer> = xs.of(
    function initReducer(prevState: State): State {
      const initialState = {
        plans: [], 
        purchase_orders: [],
        firstPlan: {},
      }
      return initialState
    }
  )
  const planReducer$: xs<Reducer> = httpSource.select('plan')
    .flatten()
    .map(res => function planReducer(prevState) {
      return {
        ...prevState, 
        plans: res.body
      }
    })
  return xs.merge(initReducer$, planReducer$)
}
function main(sources: Sources): Sinks {
  const component = isolate(sub, {onion: subLens})(sources)

  const parentRequests$ = intent()
  const requests$ = xs.merge(parentRequests$, component.HTTP)

  const parentReducer$ = model(sources.HTTP)
  const reducer$ = xs.merge(parentReducer$, component.onion)

  const state$ = xs.merge(sources.onion.state$, component.state$)
``` 

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex08_sub.ts`

``` js
...
function model(httpSource): xs<Reducer> {
  const initialReducer$: xs<Reducer> = xs.of( (prevState: State): State => ({
    plans: [],
    purchase_orders: [],
    firstPlan: {},
  }))
  const firstPlanReducer$: xs<Reducer> = httpSource.select('purchase_order')
    .flatten()
    .map( value => function firstPlanReducer(prevState) {
      return {
        ...prevState,
      }
    })
  return xs.merge(firstPlanReducer$)
}
``` 

#### Compiling and running TypeScript files

Edit `~/projects/study/js/ex/study_notes_cyclejs/tsconfig.json`

``` js
{
  "compileOnSave": false,
  "compilerOptions":
  {
    "skipLibCheck": true,
    "rootDir": "./src",
    "outDir": "./dist",
    "module": "CommonJS",
    "sourceMap": true,
		"removeComments": true,
		"preserveConstEnums": true,
    "target": "ES5"
  },
  "exclude": [
    "node_modules"
  ],
  "skipLibCheck": true
}
``` 

``` bash
cd ~/projects/study/js/ex/study_notes_cyclejs
tsc
node dist/problems/p16//ex08.js
``` 

#### p16.08a Add type annotations: Sinks problem

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p16/ex08a.ts`

``` js
function main(sources: Sources): Sinks {
...
  const component = isolate(sub, {onion: subLens})(sources)
  const parentReducer$ = model(sources.HTTP)
  const reducer$ = xs.merge(parentReducer$, component.onion)

  const onion2: xs<(s: any) => any> = component.onion
  const onion3: xs<(s: any) => any> = parentReducer$
  const onion4: xs<(s: any) => any> = xs.merge(parentReducer$, component.onion)
  const sinks: Sinks = {
    //onion: parentReducer$,
    onion: reducer$,
    HTTP: requests$,
  }
  return sinks
}
``` 

`onion2` and `onion3` are ok, but `onion4` gives the following type error by tyscript compiler:

    Type '{ onion: Stream<{} | Reducer>; HTTP: Stream<{} | { url: string; method: string; headers: { "Autho...' is not assignable to type 'Sinks'.
      Types of property 'onion' are incompatible.
        Type 'Stream<{} | Reducer>' is not assignable to type 'Stream<(s: any) => any>'.
          Type '{} | Reducer' is not assignable to type '(s: any) => any'.
            Type '{}' is not assignable to type '(s: any) => any'.
              Type '{}' provides no match for the signature '(s: any): any'.

The difference between them is: `xs.merge`. So this modifies the type from `Stream<Reducer>` to `Stream<{} | Reducer>`

To solve the problem, make `sinks` of type `any`

``` js
...
  const sinks: any = {
    //onion: parentReducer$,
    onion: reducer$,
    HTTP: requests$,
  }
  return sinks
``` 

### p16.09 Implement custom type-safe `isolate` 

Custom `isolate` comes from `ex03_isolate.js`.

Type-safe use of cyclejs comes from `ex08.ts`

Let's merge them together.



## p17: Systematic elimination of possible bug causes id=g_10219

		p17: Systematic elimination of possible bug causes <url:file:///~/projects/study/js/study_notes_cyclejs.Rmd#r=g_10219>

The application gives the following error message:

		TypeError: Cannot read property '_add' of undefined
		index.js:112
				at Merge._start (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/index.js:112:1)
				at Stream._add (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/index.js:873:1)
				at ConcatProducer._start (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/extra/concat.js:13:1)
				at Stream._add (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/index.js:873:1)
				at Stream._add (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/index.js:861:1)
				at Fold._start (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/index.js:551:1)
				at MemoryStream._add (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/index.js:1708:1)
				at Drop._start (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/index.js:345:1)
				at Stream._add (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/index.js:873:1)
				at Filter._start (/Users/mertnuhoglu/projects/study/js/vrp/ex/cyclejs_vrp/ex15/node_modules/xstream/index.js:439:1)

The stacktrace doesn't show exact location where the bug occurs. And I don't understand anything of the error message. 

I need to eliminate all possible bug causes systematically.

### Put debug(console.log) to each stream

I put debug() expression after each stream to find out where exactly the problem might have occurred.

``` js
 const requests$ = xs.merge(
    parentRequests$,
    planPanelSinks.HTTP,
  )
    .debug(x => { console.log("app/index main requests$"); console.log(x); })
``` 

### p17_01: Initial application

``` bash
npm run p17_01
``` 

This is the baseline version. This gives the above error message.

### p17_02: Elimination of DetailPanel Component

``` bash
npm run p17_02
``` 

I eliminated `DetailPanel` component. Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p17/ex02/components/app/index.ts`

``` js
...
export default function main(sources: Sources): Sinks {
...
  // const detailPanelSinks = isolate(DetailPanel, {storage: null, onion: null, Hot: null})(sources)
	...
  const vdom$ = xs.combine(
    headerSinks.DOM,
		planPanelSinks.DOM,
    // detailPanelSinks.DOM,
  ).map( ([
    header, 
    plan_panel, 
    // detail_panel
  ]) =>
    div('.vrp_container',
      [
        header,
        plan_panel,
        // detail_panel, 
      ]
    )
  )
    .debug(x => { console.log("app/index main vdom$"); console.log(x); })
	...
  // const hot$ = detailPanelSinks.Hot
  //   .debug(x => { console.log("app/index main hot$"); console.log(x); })
  const sinks: any = {
    DOM: vdom$,
    HTTP: requests$,
    // Hot: hot$,
    onion: reducer$,
  }
  return sinks;
}
``` 

I still get the above error message. I also get the log messages from `debug` expressions but I still cannot locate the exact location of the bug.

		app model return$
		model.ts:24 ƒ initReducer(prevState) {
						var initialState = {
								plans: [],
								purchase_orders: [],
								firstPlan: {}
						};
						return initialState;
				}
		index.ts:28 app/index main parentReducer$
		index.ts:28 ƒ initReducer(prevState) {
						var initialState = {
								plans: [],
								purchase_orders: [],
								firstPlan: {}
						};
						return initialState;
				}
		index.ts:30 app/index main reducer$
		index.ts:30 ƒ initReducer(prevState) {
						var initialState = {
								plans: [],
								purchase_orders: [],
								firstPlan: {}
						};
						return initialState;
				}
		index.ts:300 PlanPanel state$
		index.ts:300 Object
		index.ts:295 PlanPanel panel_vdom$
		index.ts:295 Object
		index.ts:49 app/index main vdom$
		index.ts:49 Object
		index.js:112 Uncaught TypeError: Cannot read property '_add' of undefined

### p17.03: Elimination of PlanPanel.vdom$

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p17/ex03/components/app/index.ts

``` js
...
  const vdom$ = xs.combine(
    headerSinks.DOM,
    // planPanelSinks.DOM,
    // detailPanelSinks.DOM,
  ).map( ([
    header, 
    // plan_panel, 
    // detail_panel
  ]) =>
    div('.vrp_container',
      [
        header,
        // plan_panel,
        // detail_panel, 
      ]
    )
  )
``` 

Now, the app works properly. The log messages are as follows:

		app/index main vdom$
		index.ts:49 Object
		intent.ts:16 app intent requests$
		intent.ts:16 Object
		index.ts:55 app/index main requests$
		index.ts:55 Object
		index.ts:52 PlanPanel intent requests$
		index.ts:52 Object
		index.ts:55 app/index main requests$
		index.ts:55 Object

Let's compare the log messages with and without `plan_panel`

``` js
app model return$
_stream_readable.js:1019 ƒ initReducer(prevState) {
        var initialState = {
            plans: [],
            purchase_orders: [],
            firstPlan: {}
        };
        return initialState;
    }
index.ts:28 app/index main parentReducer$
index.ts:28 ƒ initReducer(prevState) {
        var initialState = {
            plans: [],
            purchase_orders: [],
            firstPlan: {}
        };
        return initialState;
    }
index.ts:30 app/index main reducer$
index.ts:30 ƒ initReducer(prevState) {
        var initialState = {
            plans: [],
            purchase_orders: [],
            firstPlan: {}
        };
        return initialState;
    }
_stream_writable.js:687 PlanPanel state$
_stream_writable.js:687 {plans: Array(0), purchase_orders: Array(0), firstPlan: Array(0)}
_stream_writable.js:687 PlanPanel panel_vdom$
_stream_writable.js:687 {sel: "article#plan_panel.card", data: {…}, children: Array(2), text: undefined, elm: undefined, …}
index.ts:49 app/index main vdom$
index.ts:49 {sel: "div.vrp_container", data: {…}, children: Array(2), text: undefined, elm: undefined, …}
10_03b.3015f0a2.js:247 Uncaught TypeError: Cannot read property '_add' of undefined
``` 

Without `plan_panel`, `intent.requests$` is not triggered.

### Cause of the Problem

``` js
  const reducer$ = xs.merge(
    parentReducer$, 
    planPanelSinks.onion
``` 

`planPanelSinks.onion` is `undefined` because `PlanPanel` doesn't return `onion` property.

``` js
export function PlanPanel(sources) {
  const state$ = sources.onion.state$
    .debug(x => { console.log("PlanPanel state$"); console.log(x); })
  const {actions, requests$} = intent(sources.DOM)
	requests$
    .debug(x => { console.log("PlanPanel requests$"); console.log(x); })
  const sinks = {
    DOM: view(state$),
    HTTP: requests$,
  }
  return sinks
``` 

We should return `onion` property in the response object. Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p17/ex04/components/plan_panel/index.ts`

``` js
export function PlanPanel(sources) {
  const state$ = sources.onion.state$
    .debug(x => { console.log("PlanPanel state$"); console.log(x); })
  const {actions, requests$} = intent(sources.DOM)
	requests$
    .debug(x => { console.log("PlanPanel requests$"); console.log(x); })
  const reducer$ = model(sources)
  const sinks = {
    DOM: view(state$),
    HTTP: requests$,
    onion: reducer$,
  }
  return sinks
}
``` 

### Did Systematic Elimination Really Work?

Systematic elimination reduced my focus into PlanPanel component first. Then it reduced my focus into `intent()`. 

Then I noticed that `intent()` is not called when the error occurs. I knew that `intent` returns `requests$` and `requests$` is used by `model()` functions.

So, I decided to focus into `model()`. I commented `planReducer$` inside `model()`. Then I noticed that `PlanPanel.model()` was not being called at all. Thus there was no `onion` property in the returned response of `PlanPanel`.

### Why Didn't TypeScript Give an Error for undefined variable?

``` js
  const reducer$ = xs.merge(
    parentReducer$, 
    planPanelSinks.onion
  )
``` 

`planPanelSinks.onion` is `undefined`. 

But this doesn't break any type constraint.

## p18: Why Does `isolate()` Remove Type Information? Reimplementing `isolate()` id=g_10223

		p18: Why Does `isolate()` Remove Type Information? Reimplementing `isolate()` <url:file:///~/projects/study/js/study_notes_cyclejs.Rmd#r=g_10223>

### p18.01: Base Node App

Based on 

		"p02_03: Why does `isolate()` remove type information?"  <url:file:///~/projects/study/js/study_ts.Rmd#r=g_10222>
		`~/projects/study/js/ex/study_notes_cyclejs/src/problems/p15/ex04.js`

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/ex01.ts`

``` js
type Sinks = { onion: xs<(s: any) => any | undefined> }
interface State_a { field_a: String }
interface State_b { field_b: String }
type Reducer_a = (prev?: State_a) => State_a | undefined
type Reducer_b = (prev?: State_b) => State_b | undefined
function model_a(): xs<Reducer_a> {
    return xs.of(
        function initReducer(prevState: State_a) {
            return { field_a: "a" }
        }
    )
}
function model_b(): xs<Reducer_b> {
    return xs.of(
        function initReducer(prevState: State_b) {
            return { field_b: "b" }
        }
    )
}

function main(): Sinks {
    const parentReducer$ = model_a()
    const compReducer$ = model_b()
    const reducer$ = xs.merge(
        parentReducer$,
        compReducer$
    )
    const sinks: Sinks = {
        onion: reducer$
    }
    return sinks
}

main().onion.addListener({ next: console.log })
``` 

### p18.02: Encapsulate Components into Their Own Functions

Edit `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/ex02.ts`

``` js
...
function comp_b(): Sinks {
    const reducer$ = model_b()
    const sinks: Sinks = {
        onion: reducer$
    }
    return sinks
}
function comp_a(): Sinks {
    const parentReducer$ = model_a()
    const cmp_b = comp_b()
		...
``` 

### p18.03: Custom `onionify()`

Original `onionify()` is defined in `cycle-onionify` here: `~/codes/js/cycle-onionify/src/onionify.ts`

Based on `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p15/ex04.js`

``` js
function main(): Sinks {
    const mainOnionified = onionify(comp_a)
    const sources = {}
    const sinks = mainOnionified(sources)
    return sinks
}
``` 

`onionify()` function removes type information. The returned `mainOnionified` object has type `MainFn<any, any>`

### p18.04: Simplify type removal with a reference example. Step 01: Remove `So`

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/ex04.ts`

``` js
type MainFn<Si> = () => Si
type Reducer<T> = (state: T) => T
type OSi<T> = {onion: Stream<Reducer<T>>};
type Omit<T, K extends keyof T> = any;
type MainOnionified<T, Si extends OSi<T>> = MainFn<Omit<Si, 'onion'>>;
function onionify<T, So, Si extends OSi<T>>(main: MainFn<Si>): MainOnionified<T, Si> {
    return function mainOnionified(): Omit<Si, 'onion'> {
        let sources = {onion: undefined}
        const reducerMimic$ = xs.create<Reducer<T>>();
        const state$ = reducerMimic$
            .fold((state, reducer) => reducer(state), void 0 as (T | undefined))
            .drop(1);
        sources.onion = {state$}
        const sinks = main();
        reducerMimic$.imitate(sinks.onion);
        return sinks;
    }
}
function main(): Sinks {
    const mainOnionified = onionify(comp_a)
    const sinks = mainOnionified()
    return sinks
}

console.log("ex04.ts")
main().onion.addListener({ next: console.log })
``` 

Type of `mainOnionified` is `MainFn<any>`

### p18.05: Simplify type removal with a reference example. Step 02: Remove `Omit`

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/ex05.ts`

Remove the following line:

``` ts
type Omit<T, K extends keyof T> = any;
``` 

``` js
type MainFn<Si> = () => Si
type Reducer<T> = (state: T) => T
type OSi<T> = {onion: Stream<Reducer<T>>};
type MainOnionified<T, Si extends OSi<T>> = MainFn<Sinks>;
function onionify<T, So, Si extends OSi<T>>(main: MainFn<Si>): MainOnionified<T, Si> {
    return function mainOnionified(): Sinks {
        let sources = {onion: undefined}
        const reducerMimic$ = xs.create<Reducer<T>>();
        const state$ = reducerMimic$
            .fold((state, reducer) => reducer(state), void 0 as (T | undefined))
            .drop(1);
        sources.onion = {state$}
        const sinks = main();
        reducerMimic$.imitate(sinks.onion);
        return sinks;
    }
}
function main(): Sinks {
    const mainOnionified = onionify(comp_a)
    const sinks = mainOnionified()
    return sinks
}
``` 

Now, the type of `mainOnionified` is `MainFn<Sinks>`. 

`Omit` was equivalent to `any`. Therefore the type of `mainOnionified` was becoming `MainFn<any>`

``` js
type Omit<T, K extends keyof T> = any;
type MainOnionified<T, Si extends OSi<T>> = MainFn<Omit<Si, 'onion'>>;
function onionify<T, So, Si extends OSi<T>>(main: MainFn<Si>): MainOnionified<T, Si> {
    return function mainOnionified(): Omit<Si, 'onion'> {
``` 

### p18.06: Implement Omit with type safety

With TypeScript 2.1 comes new keywords `Pick` and `Exclude`. They can be used as type subtraction operator:

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/ex06.ts`

``` js
type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>
``` 

But now I get another error:

``` ts
function main(): Sinks {
    const mainOnionified = onionify(comp_a)
    const sinks = mainOnionified()
    return sinks // error
}
``` 

		Type 'Pick<Sinks, never>' is not assignable to type 'Sinks'.
		Property 'onion' is missing in type 'Pick<Sinks, never>'

### p18.07: Implement onionify without Omit

I couldn't understand why `Omit` is used in `onionify`. I omitted `Omit`. Now type safety is provided.

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/ex07.ts`

``` ts
...
type MainOnionified<T, Si extends OSi<T>> = MainFn<Si>;
function onionify<T, So, Si extends OSi<T>>(main: MainFn<Si>): MainOnionified<T, Si> {
    return function mainOnionified(): Si {
		...
``` 

### p18.08: Implement onionify without Omit. Step 02

Current MainFn generifies only Sinks. It should also generify Sources.

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/ex08.ts`

Implementation of type-safe `Omit` and `MainOnionified`:

``` ts
...
type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>> // @essence

type MainOnionified<T, So extends OSo<T>, Si extends OSi<T>> =
    MainFn<Omit<So, 'onion'>, Si>;
export function onionify<T, So extends OSo<T>, Si extends OSi<T>>(
    main: MainFn<So, Si>,
    name: string = 'onion'): MainOnionified<T, So, Si> {
``` 

This implementation requires `Sources` to be defined in terms of `State`. But there is not a super type `State`.

``` ts
type Sources = { onion: StateSource<State> }
``` 

As a remedy, I defined `State` as a union of state types of all subcomponents:

``` ts
interface State_a { field_a: String }
interface State_b { field_b: String }
type State = State_a | State_b
``` 

### p18.08a: Does This Catch Errors Due To Forgetting `onion` in Sinks

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/ex08a.ts`

``` ts
function comp_b(sources: Sources): Sinks {
    // essence: removed reducer$. compiler catches the error
    // const reducer$ = model_b()
    const sinks: Sinks = {
        // onion: reducer$ 
				// Error: Type '{}' is not assignable to type 'Sinks'.
        // Property 'onion' is missing in type '{}'.
    }
    return sinks
}
``` 

I removed `onion` from `sinks` object. This caused an immediate error caught by typescript.

		// Error: Type '{}' is not assignable to type 'Sinks'.
		// Property 'onion' is missing in type '{}'.

#### p18.p01: Testing and Studying Generic Types

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/p01/ex01.ts`

``` ts
function fun01<T>(a: T): T {
    return a
}
const g: "help" = fun01("help")

type MainFn<T> = (arg: T) => T
function fun02<T>(arg01: T): MainFn<T> {
    return (arg: T) => arg
}
const g02: MainFn<string> = fun02("help")
const g03: string = g02("ali")

function fun03<T>(fun: MainFn<T>): MainFn<T> {
    return function mainFun(arg: T): T {
        return arg
    }
}
const g04: MainFn<string> = fun03(g02)
const g05: string = g04("b")
``` 

##### p18.p01.02: Refactor p18.08

I wanted to refactor p18.08 such that only the essence of the logic remains. But this didn't work as I expected because the type logic needs to changed in order to simplify as much as I want.

##### p18.p01.03: Use Conditional Types to Compare MainFn and App Types

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p18/p01/ex03.ts`

``` ts
...
import { comp_a, MainFn, Sources, Sinks, onionify, State, model_a } from './ex02'
type T22 = typeof comp_a extends MainFn<Sources, Sinks> ? never : string // never
type T23 = typeof comp_a extends MainFn<Pick<Sources, never>, Sinks> ? never : string // never
const main01 = onionify(comp_a) // MainFn<Pick<Sources, never>, Sinks>

import xs from 'xstream'
import Stream from 'xstream';
import { StateSource } from '../cycle-onionify/StateSource';
type Sources02 = { onion: StateSource<State>, DOM: {} }
type Sinks02 = { onion: xs<(s: any) => any | undefined>, DOM: {} }
function comp_b(sources: Sources02): Sinks02 { 
    return { 
        onion: model_a(),
        DOM: {},
    }
}
const main02 = onionify(comp_b) // MainFn<Pick<Sources02, "DOM">, Sinks02>
``` 

Conditional type checkings show that `comp_a` and `comp_b` can be assigned to `MainFn` 

## p19: Test: addListener doesn't consume streaming data

I want to verify that `addListener` doesn't consume streaming data. 

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p19/ex01.ts`

``` ts
var stream = xs.periodic(1000)
  .map(i => i)
  .endWhen(xs.periodic(5000).take(1))

stream.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})

// 0
// 1
// 2
// 3
// completed
``` 

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p19/ex02.ts`

``` ts
var stream = xs.periodic(1000)
  .map(i => i)
  .endWhen(xs.periodic(5000).take(1))

const s2 = stream
  .map(i => i + 10)
  .debug(console.log)

stream.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})

// 0
// 1
// 2
// 3
// completed
``` 

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p19/ex03.ts`

``` ts
...
const s2 = stream
  .map(i => i + 10)
  .debug(console.log)

s2.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})

// 10
// 10
// 11
// 11
// 12
// 12
// 13
// 13
// completed
``` 

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p19/ex04.ts`

``` ts
...
const s2 = stream
  .map(i => i + 10)

s2.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})

// 0
// 10
// 1
// 11
// 2
// 12
// 3
// 13
// completed
``` 

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p19/ex05.ts`

``` ts
...
stream.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})
s2.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})

// 0
// 10
// 1
// 11
// 2
// 12
// 3
// 13
// completed
``` 

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p19/ex06.ts`

``` ts
...
const s3 = stream
  .map(i => i + 20)
  .debug()

stream.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})
s2.addListener({
  next: i => console.log(i),
  error: err => console.error(err),
  complete: () => console.log('completed'),
})

// 0
// 10
// 1
// 11
// 2
// 12
// 3
// 13
// completed
``` 

## p20: Type-safe Component Usage

First example is using a component without `isolate`.

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p20/ex01.ts`

``` ts
...
function comp_a(sources: Sources): Sinks {
    const parentReducer$ = model_a()
    const cmp_b = comp_b(sources)
    const reducer$ = xs.merge(
        parentReducer$,
        cmp_b.onion,
    )
    const sinks: Sinks = {
        onion: reducer$
    }
		...
``` 

Second example uses isolate. 

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p20/ex02.ts`

``` ts
...
    const cmp_b = isolate(comp_b) as Component<Sources, Sinks>
    const sinks_b = cmp_b(sources)
    const reducer$ = xs.merge(
        parentReducer$,
        sinks_b.onion,
    )
		...
``` 

`cmp_b` accepts an argument of type `Sources`. `isolate(comp_b)` returns an object of this type.

Third example: What happens when `cmp_b` accepts an argument of type `Sources & SoHTTP`

``` ts
...
function comp_b(sources: Sources & SoHTTP): Sinks {
    sources.HTTP.debug() // @essence
    const reducer$ = model_b()
    const sinks: Sinks = {
        onion: reducer$
    }
    return sinks
}
function comp_a(sources: Sources): Sinks {
    const parentReducer$ = model_a()
    const cmp_b = isolate(comp_b) as Component<Sources, Sinks>
    const sinks_b = cmp_b(sources) // @essence
    const reducer$ = xs.merge(
        parentReducer$,
        sinks_b.onion,
    )
		...
``` 

Now, on runtime I get the following error:

		TypeError: Cannot read property 'debug' of undefined
		ex03.ts:31
				at comp_b (/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p20/ex03.ts:31:18)

TypeScript cannot catch this error on compile time. Why? `sources` is not of type `Sources & SoHTTP`. Note that, `comp_b` and `cmp_b` has different type signatures. `cmp_b` is of type `cmp_b: Component<Sources, Sinks>`

We need to make `cmp_b: Component<Sources & SoHTTP, Sinks>`

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p20/ex04.ts`

``` ts
...
    const cmp_b = isolate(comp_b) as Component<Sources & SoHTTP, Sinks> // @essence
    const sinks_b = cmp_b(sources) // Error: Argument of type 'Sources' is not assignable to parameter of type 'Sources & SoHTTP'.
		...
``` 

Now, we get a compile time type error. 

We can of course use type assertion:

		    const sinks_b = cmp_b(sources as Sources & SoHTTP)

But this is too verbose. 

Can we make `isolate` return correct type?

Edit `/Users/mertnuhoglu/projects/study/js/ex/study_notes_cyclejs/src/problems/p20/ex05.ts`

We need to change type definitions of `isolate`. Let's do it later.

For now, apply a fast fix:

``` ts
function comp_a(sources: Sources & SoHTTP): Sinks {
...
``` 

# xstream Operators

## between: `first.mapTo(source.endWhen(second)).flatten()`

From `~/codes/js/cyclejs/examples/advanced/autocomplete-search/src/app.js`

``` js
/**
 * source: --a--b----c----d---e-f--g----h---i--j-----
 * first:  -------F------------------F---------------
 * second: -----------------S-----------------S------
 *                         between
 * output: ----------c----d-------------h---i--------
 */
function between(first, second) {
  return (source) => first.mapTo(source.endWhen(second)).flatten()
}
...
  const inputBlurToItem$ = inputBlur$.compose(between(itemMouseDown$, itemMouseUp$))
``` 

``` js
/**
 * source: --a--b----c----d---e-f--g----h---i--j-----
 * first:  -------F------------------F---------------
 * second: -----------------S-----------------S------
 *                       notBetween
 * output: --a--b-------------e-f--g-----------j-----
 */
function notBetween(first, second) {
  return source => xs.merge(
    source.endWhen(first),
    first.map(() => source.compose(dropUntil(second))).flatten()
  )
}
...
  const inputBlurToElsewhere$ = inputBlur$.compose(notBetween(itemMouseDown$, itemMouseUp$))
``` 

# Opinions

## Opinion01: What do we get for free by using reactive programming?

Andre Staltz says in his article http://cycle.js.org/observables.html#reactive-programming:

Assume that `foo` module affects `bar` module in such a way:

    class foo 
      function onRequest() {
        bar.increment()
      }

Here `foo` is proactive and `bar` is passive. Shown as foo -> bar

In this case, we can classify knowledge discovery with the following table:

    |                         | passive     | reactive    |
    | how does bar work?      | find usages | look inside |
    | which modules affected? | look inside | find usages |

Let's see if this is valid for our code in `~/projects/study/js/ex/study_notes_cyclejs/src/problems/p07/ex08/index.js` too:

The state data is managed by `model()` function. 

``` js
function model(actions) {
  const newItem$ = actions.newItem$.map( title =>
    function newItemReducer(prevState){
      return {        
        max_id: prevState.max_id + 1,
        items: [
          ...prevState.items,
          {"item_id": (prevState.max_id + 1), "title": title},
        ]}
    })
  const removeItem$ = actions.removeItem$.map(action => function removeItemReducer(prevState) {
    return {
      ...prevState,
      items: prevState.items.filter(item => item.item_id !== +action.payload)
    }
  })
  return {newItem$, removeItem$}
}
``` 

Here we can see how state update logic is designed. 

What about all the modules that are affected by `model()`. For this information we have to find all usages of `model()`

``` js
  const reducers = model(actions)
``` 

